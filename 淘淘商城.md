# 测试整合结果

## 需求

跟据商品id查询商品信息。sql语句：SELECT * from tb_item WHERE id=536563

## Dao层

可以使用逆向工程生成的mapper文件。这样就不需要自己写sql语句，所有常见的数据库交互操作的mapper文件和对应的pojo对象都自动创建了。

## Service层

接收商品id调用dao查询商品信息。返回商品pojo对象。

com.taotao.service/ItemService.java

```java
// 根据商品id获取商品信息的接口
public interface ItemService {
	TbItem getItemById(long itemId);
}
```

com.taotao.service.impl/ItemServiceImpl.java

```java
@Service
public class ItemServiceImpl implements ItemService {

	@Autowired
	private TbItemMapper itemMapper;
	
	@Override
	public TbItem getItemById(long itemId) {
		
		//TbItem item = itemMapper.selectByPrimaryKey(itemId);
		//添加查询条件
		TbItemExample example = new TbItemExample();
		Criteria criteria = example.createCriteria();
		criteria.andIdEqualTo(itemId);
		List<TbItem> list = itemMapper.selectByExample(example);
		if (list != null && list.size() > 0) {
			TbItem item = list.get(0);
			return item;
		}
		return null;
	}

}
```

## Controller层

接收页面请求商品id，调用service查询商品信息。直接返回一个json数据。需要使用@ResponseBody注解。

```java
@Controller
public class ItemController {

	@Autowired
	private ItemService itemService;
	
	@RequestMapping("/item/{itemId}")
	@ResponseBody
	public TbItem getItemById(@PathVariable Long itemId) {
		TbItem tbItem = itemService.getItemById(itemId);
		return tbItem;
	}
}
```

> 注意非war包中的.xml文件需要进行配置，否则在构建的时候会漏掉.xml文件。比如在这个测试中，如果不对mapper的.xml文件配置，最终生成的classes文件中将没有.xml文件，导致找不到映射文件的异常。

```XML
<!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 -->
	<build>
		<resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
	</build>
```

## 测试

启动服务器，在网页中访问http://localhost:8080/item/536563，其中536563是要查询的商品的id。


# 商品列表查询展示

## 后台管理系统页面

我们的目的是打开后台管理工程的首页

分析：先写一个controller进行页面跳转来展示首页

```java
// PageController.java

@Controller
public class PageController {
	/**
	 * 打开首页
	 */
	@RequestMapping("/")
	public String showIndex() {
		return "index";
	}
	/**
	 * 展示其他页面
	 * <p>Title: showpage</p>
	 * <p>Description: </p>
	 * @param page
	 * @return
	 */
	@RequestMapping("/{page}")
	public String showpage(@PathVariable String page) {
		return page;
	}
}

```

首页使用easyUI进行开发。静态页面包含js,css和jsp。

## 商品列表查询

### 需求分析

查询语句：SELECT * from tb_item LIMIT 0,30

请求的参数：<http://localhost:8080/item/list?page=1&rows=30>  分页信息。（请求的参数信息可以通过浏览器审查元素进行查询）

### Dao层-分页插件的使用

分页插件

Github上有一个开源项目Mybatis-PageHelper，是目前最简单的分页插件。

#### 实现原理

MyBatis中有一个SqlsessionFactory工厂类，用来创建SqlSession对象；SqlSession对象中含有很多用户方法，用来执行sql语句；具体来说，SqlSession里面有一个Executor对象，用来执行sql语句；而在mybatis里面，sql语句被封装为MappedStatement；

MyBatis中有一个拦截器——Interceptor接口，它会在在执行sql语句之前执行（一些具有某些功能的插件就会实现这个拦截器接口）；我们可以在sql语句中添加limit语句，实现分页处理。

#### 使用方法

第一步：引入pageHelper的jar包。

第二步：需要在SqlMapConfig.xml中配置插件。

```xml
<!-- 配置分页插件 -->
<plugins>
	<plugin interceptor="com.github.pagehelper.PageHelper">
		<!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库-->       
        <property name="dialect" value="mysql"/>
	</plugin>
</plugins>
```

第三步：在查询的sql语句执行之前，添加一行代码：PageHelper.startPage(1, 10);第一个参数是page，要显示第几页。第二个参数是rows，每页显示的记录数。

第四步：取查询结果的总数量。创建一个PageInfo类的对象，从对象中取分页信息。

#### 分页测试

```java
// 测试类 位于taotao-manager-web/src/test/java/TestPageHelper

public class TestPageHelper {
	@Test
	public void testPageHelper() {
		//创建一个spring容器
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-*.xml");
		//从spring容器中获得Mapper的代理对象
		TbItemMapper mapper = applicationContext.getBean(TbItemMapper.class);
		//执行查询，并分页
		TbItemExample example = new TbItemExample();
		//分页处理 
        //获取第1页的10条内容
		PageHelper.startPage(1, 10);
        //紧跟着的第一个select方法会被分页
		List<TbItem> list = mapper.selectByExample(example);
		//取商品列表
		for (TbItem tbItem : list) {
			System.out.println(tbItem.getTitle());
		}
		//取分页信息
        //分页后，实际返回的结果list类型是Page<E>，如果想取出分页信息，需要强制转换为Page<E>
		PageInfo<TbItem> pageInfo = new PageInfo<>(list);
		long total = pageInfo.getTotal();
		System.out.println("共有商品："+ total);
		
	}
}
```

>分页插件对逆向工程生成的代码支持不好，不能对有查询条件的查询分页。会抛异常。使用修改过的版本就可以了。（资料中给出了修改过后的分页插件pagehelper-3.4.2-fix）

通过以上配置，Dao已经可以实现逆向工程生成的mapper文件+PageHelper实现，但是我们还需要将分页应用到后台管理的页面上。

### Service层

接收分页参数，一个是page一个是rows，然后根据这些参数调用dao查询商品列表并分页，最后返回商品列表。

Easyui中datagrid控件要求的数据格式为json格式：{total:”2”,rows:[{“id”:”1”,”name”,”张三”},{“id”:”2”,”name”,”李四”}]}，所以我们需要创建一个Pojo来返回一个EasyUIDateGrid支持的json数据格式。这个pojo可能会被多个项目使用，所以此pojo应该放到taotao-common工程中。

```java
// 位于taotao-common/src/main/java/com.taotao.common.pojo

public class EUDataGridResult {

	private long total;
	private List<?> rows;
	public long getTotal() {
		return total;
	}
	public void setTotal(long total) {
		this.total = total;
	}
	public List<?> getRows() {
		return rows;
	}
	public void setRows(List<?> rows) {
		this.rows = rows;
	}
	
}
```

在service层的ItemService接口和实现类中，添加获取带分页的查询商品列表的方法

```java
// 查询商品列表方法 位于ItemServiceImpl.java

public EUDataGridResult getItemList(int page, int rows) {
	//查询商品列表
	TbItemExample example=new TbItemExample();
	//分页处理
	PageHelper.startPage(page, rows);
	List<TbItem> list = itemMapper.selectByExample(example);
	//創建一個返回值對象
	EUDataGridResult result=new EUDataGridResult();
	result.setRows(list);
	//取記錄總條數
	PageInfo<TbItem> pageInfo=new PageInfo<>(list);
	result.setTotal(pageInfo.getTotal());
	return result;
}
```

### Controller层

接收页面传递过来的参数page、rows；返回json格式的数据；EUDataGridResult需要使用到@ResponseBody注解。

```java
// 实际上就是传递page和rows参数给service层中的查询商品列表方法
// 位于ItemController.java

@RequestMapping("/item/list")
@ResponseBody
public EUDataGridResult getItemList(Integer page,Integer rows) {
	EUDataGridResult result=itemService.getItemList(page, rows);
	return result;
}
```

# 商品类目选择

## 需求

在商品添加页面，点击“选择类目”显示树状的商品类目列表；

要求是一个动态树，可以自由选择将闭合的节点展开；

使用EasyUI的异步Tree控件来实现这个“选择类目”功能；

异步Tree：在将闭合节点展开的时候，再做一次查询，将该闭合节点的子节点查询显示出来；

EasyUI的异步树的原理：树支持内置的异步加载模式，因此用户可以创建一个空的树，然后指定一个动态返回 JSON 数据的服务器端，用于根据需求异步填充树。子节点依赖于父节点状态被加载。当展开一个关闭的节点时，如果该节点没有子节点加载，它将通过上面定义的 URL 向服务器发送节点的 id 值作为名为 'id' 的 http 请求参数，以便检索子节点。

每个异步Tree的节点的json数据结构：

```json
[{
    "id": 1,
    "text": "Node 1",
    "state": "closed",
},{
    "id": 2,
    "text": "Node 2",
    "state": "open"
}]
```

数据库中的tb_item_cat为商品分类，包含的列有：id,parent_id,name,status,is_parent等等

## 实现步骤

1、  按钮添加点击事件，弹出窗口，加载数据显示tree

2、  将选择类目的组件封装起来，通过TT.iniit()初始化，最终调用initItemCat()方法进行初始化

3、  创建数据库、以及tb _item_cat表，初始化数据

4、  编写Controller、Service、Mapper

## JSP

selectItemCat作为这个jsp的绑定事件；

```html
<!--该代码位于item_add.jsp-->	
<a href="javascript:void(0)" class="easyui-linkbutton selectItemCat">选择类目</a>
```

使用eclipse的file search功能搜索selectItemCat，默认搜索workspace里面的所有内容，可以设置要搜索的文件的后缀名。

发现selectItemCat位于common.js中。

```javascript
initItemCat : function(data){
    $(".selectItemCat").each(function(i,e){
        var _ele = $(e);
        if(data && data.cid){
            _ele.after("<span style='margin-left:10px;'>"+data.cid+"</span>");
        }else{
            _ele.after("<span style='margin-left:10px;'></span>");
        }
        _ele.unbind('click').click(function(){
            $("<div>").css({padding:"5px"}).html("<ul>")
                .window({
                width:'500',
                height:"450",
                modal:true,
                closed:true,
                iconCls:'icon-save',
                title:'选择类目',
                onOpen : function(){
                    var _win = this;
                    $("ul",_win).tree({
                        // 请求初始化树形视图的url
                        url:'/item/cat/list',
                        animate:true,
                        // 点击父节点，请求初始化子节点的动作是tree控件封装好的。每打开一个父节点做以前的ajax请求
                        onClick : function(node){
                            if($(this).tree("isLeaf",node.target)){
                                // 填写到cid中
                                _ele.parent().find("[name=cid]").val(node.id);
                                _ele.next().text(node.text).attr("cid",node.id);
                                $(_win).window('close');
                                if(data && data.fun){
                                    data.fun.call(this,node);
                                }
                            }
                        }
                    });
                },
                onClose : function(){
                    $(this).window("destroy");
                }
            }).window('open');
        });
    });
},
```

请求初始化树形控件的url为'/item/cat/list'；

## Dao层

sql语句：SELECT * FROM  tb_item_cat WHERE parent_id=父节点id;（每次点击展开父节点的时候会执行这段sql语句）

单表查询：可以使用逆向工程生成的代码

## Service层

功能：接受parentid参数，根据parentId查询子类目类别，返回一个分类列表。所以我们需要创建一个pojo来描述json格式的节点，然后返回一个pojo的列表。

pojo的内容很简单，包含id,text和state属性。因为其他工程也可能用到这个pojo，所以应该放到taotao-common工程中。

```java
// 子类目的pojo，位于taotao-common工程中
public class EUTreeNode {
	private long id;
	private String text;
	private String state;
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getText() {
		return text;
	}
	public void setText(String text) {
		this.text = text;
	}
	public String getState() {
		return state;
	}
	public void setState(String state) {
		this.state = state;
	}
}
```

然后将从数据库中根据parentid查询到的数据有选择的封装成EUTreeNode类；

```java
@Service
public class ItemCatServiceImpl implements ItemCatService {
	
	@Autowired
	private TbItemCatMapper itemCatMapper;

	@Override
	public List<EUTreeNode> getCatList(long parentId) {
		// 创建查询条件
		TbItemCatExample example=new TbItemCatExample();
		Criteria criteria=example.createCriteria();
		criteria.andParentIdEqualTo(parentId);
		// 根据条件查询
		List<TbItemCat> list=itemCatMapper.selectByExample(example);
		List<EUTreeNode> resultList=new ArrayList<>();
		// 把列表转换为treeNodeList
		for(TbItemCat tbItemCat:list) {
			EUTreeNode node=new EUTreeNode();
			node.setId(tbItemCat.getId());
			node.setText(tbItemCat.getName());
			node.setState(tbItemCat.getIsParent()?"closed":"open");
			resultList.add(node);
		}
		return resultList;
	}

}
```

## Controller层

功能：接受页面请求的参数，名为id。调用service查询分类列表，返回json格式的列表，需要使用@ResponseBody注解

```java
@Controller
@RequestMapping("/item/cat")
public class ItemCatController {
	@Autowired
	private ItemCatService itemCatService;
	@RequestMapping("/list")
	@ResponseBody
	private List<EUTreeNode> getItemCatList(@RequestParam(value="id",defaultValue="0")Long parentId){
		List<EUTreeNode> list = itemCatService.getItemCatList(parentId);
		return list;
	}
}
```

## 问题记录

1、商品类目选择没有出现效果：在controller层没有添加@Controller注解；

2、启动服务器访问后出现http 500错误：在service层没有添加@Service注解；

# 图片上传

## 传统项目中的图片管理

传统项目中，可以在web项目中添加一个文件夹，来存放上传的图片。例如在工程的根目录WebRoot下创建一个images文件夹。把图片存放在此文件夹中就可以直接使用在工程中引用。

优点：引用方便，便于管理

缺点：

1、如果是分布式环境图片引用会出现问题：当使用tomcat集群的时候，图片上传到一个tomcat上，访问图片的时候链接到另一个tomcat的时候会找不到图片。

2、图片的下载会给服务器增加额外的压力。

## 分布式环境的图片管理

分布式环境一般都有一个专门的图片服务器存放图片。

我们使用虚拟机搭建一个专门的服务器来存放图片。在此服务器上安装一个nginx来提供http服务，安装一个ftp服务器来提供图片上传服务。

## 搭建图片服务器

### 需要安装的软件

1、linux CentOS6.4

2、Nginx

3、Vsftpd

第一步：安装vsftpd提供ftp服务

第二步：安装nginx提供http服务

### nginx的安装

参考nginx的安装手册

1、安装nginx的编译环境；

2、把nginx的代码上传到linux；

3、解压代码；

4、配置makefile；

> 1、使用yum命令将nginx的编译环境搭建好；
>
> 2、将nginx源码放到/opt文件夹中解压；
>
> 3、./configure \配置安装路径；
>
> 4、make和make install进行安装
>
> 5、在nginx可执行文件安装目录下命令./nginx启动nginx；
>
> 6、在linux浏览器中输入linux的ip地址，出现欢迎界面，说明安装成功；

启动nginx命令：./nginx

关闭nginx命令：./nginx -s stop

如果需要修改nginx的配置文件，执行命令：./nginx -s reload

### vsftpd的安装

参考ftp的安装手册

1、安装vsftpd组件

安装完后，有/etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。

[root@bogon ~]# yum -y install vsftpd

2、添加一个ftp用户

此用户就是用来登录ftp服务器用的。

[root@bogon ~]# useradd ftpuser

这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser.   

3、给ftp用户添加密码

[root@bogon ~]# passwd ftpuser

输入两次密码后修改密码。

4、防火墙开启21端口

因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件

[root@bogon ~]# vim /etc/sysconfig/iptables

在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。

还要运行下,重启iptables

[root@bogon ~]# service iptables restart

5、修改selinux

6、关闭匿名访问

修改/etc/vsftpd/vsftpd.conf文件

重启ftp服务：

[root@bogon ~]# service vsftpd restart

7、开启被动模式

默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上

pasv_min_port=30000

pasv_max_port=30999

表示端口范围为30000~30999，这个可以随意改。改完重启一下vsftpd

由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件。

也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了。

8、设置开机启动vsftpd ftp服务

[root@bogon ~]# chkconfig vsftpd on

### 访问ftp服务

<https://blog.csdn.net/csdn_lqr/article/details/53334583>

### 使用java代码访问ftp服务

使用apache的FTPClient工具访问ftp服务器。需要在pom文件中添加依赖。

```xml
<dependency>
    <groupId>commons-net</groupId>
    <artifactId>commons-net</artifactId>
    <version>${commons-net.version}</version>
</dependency>
```

在eclipse中上传文件到ftp服务器的测试

```java
public class FTPTest {
	@Test
	public void testFtpClient() throws Exception{
		// 创建一个FtpClient对象
		FTPClient ftpClient=new FTPClient();
		// 创建一个ftp连接
		ftpClient.connect("192.168.222.128",21);
		// 登录ftp服务器，使用用户名和密码
		ftpClient.login("ftpuser", "123");
		// 上传文件
		//读取本地文件
		FileInputStream inputStream=new FileInputStream(new File("D:\\Picture\\test.jpg"));
		// 设置上传的路径
		ftpClient.changeWorkingDirectory("/home/ftpuser/www/images");
		// 修改上传文件的格式
		ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
		// 第一个参数：服务器端文件名
		// 第二个参数：上传文档的inputStream
		ftpClient.storeFile("hello1.jpg", inputStream);
		// 关闭连接
		ftpClient.logout();
	}
}
```

将ftp上传功能封装成一个工具类，可以供其他项目使用，提高代码的复用性。

封装类用教程里给的工具类。

## 图片上传实现

### 图片上传Service

1、上传图片的url：/pic/upload

2、上传图片参数名称：uploadFile

3、返回结果数据类型json：参考文档<http://kindeditor.net/docs/upload.html>

```json
//成功时
{
        "error" : 0,
        "url" : "http://www.example.com/path/to/file.ext"
}
//失败时
{
        "error" : 1,
        "message" : "错误信息"
}

```

图片上传不涉及数据库，所以不需要写Dao层。

**Service层**

接受Controller传递过来的参数——一个文件MultiPartFile对象，然后把文件上传到ftp服务器，生成一个新的文件名，并返回文件url路径，需要保证满足图片上传插件要求的格式。

使用Map来实现插件要求的json格式（可以省去写pojo）：

Key                         value

------

Error                      1、0

Url                          图片的url（成功时）

Message                图片信息（错误时）

```properties
# 图片服务器的一些配置
FTP_ADDRESS=192.168.222.128
FTP_PORT=21
FTP_USERNAME=ftpuser
FTP_PASSWORD=123
FTP_BASE_PATH=/home/ftpuser/www/images
IMAGE_BASE_URL=http://192.168.222.128/images
```



```java
// 将图片上传到ftp服务器
// com.taotao.service.impl.PictureServiceImpl

@Service
public class PictureServiceImpl implements PictureService {
	// 将图片服务器菩配置通过Value注解导入
	@Value("${FTP_ADDRESS}")
	private String FTP_ADDRESS;
	@Value("${FTP_PORT}")
	private int FTP_PORT;
	@Value("${FTP_USERNAME}")
	private String FTP_USERNAME;
	@Value("${FTP_PASSWORD}")
	private String FTP_PASSWORD;
	@Value("${FTP_BASE_PATH}")
	private String FTP_BASE_PATH;
	@Value("${IMAGES_BASE_URL}")
	private String IMAGES_BASE_URL;

	@Override
	public Map uploadPicture(MultipartFile uploadFile){
		Map resultMap=new HashMap<>();
		try {
			// 生成一个新的文件名
			// 取原始文件名
			String oldName=uploadFile.getOriginalFilename();
			// 生成新的文件名
			// UUID.randomUUID();
			String newName=IDUtils.genImageName();
			// 截取扩展名
			newName=newName+oldName.substring(oldName.lastIndexOf("."));
			// 图片上传
			String imagePath=new DateTime().toString("/yyyy/MM/dd");
			boolean result=FtpUtil.uploadFile(FTP_ADDRESS, FTP_PORT, FTP_USERNAME, FTP_PASSWORD, FTP_BASE_PATH, imagePath, newName, uploadFile.getInputStream());
			// 返回结果
			if(!result) {
				resultMap.put("error",1);
				resultMap.put("message","文件上传失败");
				return resultMap;
			}
			resultMap.put("error",0);
			resultMap.put("url", IMAGES_BASE_URL+imagePath+"/"+newName);
			return resultMap;
			
		}catch (Exception e) {
			// TODO: handle exception
			resultMap.put("error",1);
			resultMap.put("message","文件上传发生异常");
			return resultMap;
		}

	}

}
```

### 图片上传Controller

功能：接收页面传递过来的图片，调用service上传到图片服务器，然后返回json数据格式的结果（使用@ResponseBody注解）。

参数：MultiPartFile uploadFile

返回值：返回json数据，可以返回一个pojo，PictureResult对象，也可以返回一个map。

```java
// com.taotao.controller.PictureController

@Controller
public class PictureController {
	@Autowired
	private PictureService pictureService;
	
	@RequestMapping("/pic/upload")
	@ResponseBody
	public Map pictureUpload(MultipartFile uploadFile) {
		Map result=pictureService.uploadPicture(uploadFile);
		return result;
	}
}
```

需要引入file-upload和common-io包（在pom文件中已经添加了依赖）；

需要在SpringMVC.xml中配置多部件解析器，添加如下内容：

```xml
<!-- 定义文件上传解析器 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<!-- 设定默认编码 -->
		<property name="defaultEncoding" value="UTF-8"></property>
		<!-- 设定文件上传的最大值5MB，5*1024*1024 -->
		<property name="maxUploadSize" value="5242880"></property>
	</bean>
```

为了解决浏览器兼容性的问题，需要将map转换为json格式，才能使上传图片插件在多个浏览器中可用。

```java
@Controller
public class PictureController {
	@Autowired
	private PictureService pictureService;
	
	@RequestMapping("/pic/upload")
	@ResponseBody
	public String pictureUpload(MultipartFile uploadFile) {
		Map result=pictureService.uploadPicture(uploadFile);
		// 为了保证功能的兼容性，需要把Result转换为json格式的字符串
		String json=JsonUtils.objectToJson(result);
		return json;
	}
}
```

# 商品添加实现

## 富文本编辑器

功能：添加商品描述的文本编辑窗口；（前端知识）

第一步：在jsp中加入富文本编辑器js的引用。

第二步：在富文本编辑器出现的位置添加一个input 类型为textarea

第三步：调用js方法初始化富文本编辑器。

第四步：提交表单时，调用富文本编辑器的同步方法sync，把富文本编辑器中的内容同步到textarea中。

## 商品添加实现

### 需求分析

1、请求的url：/item/save

2、返回结果，自定义一个TaotaoResult类，类的具体内容参见参考资料。

### Dao层

数据库中分为商品表、商品描述表；分开的目的是为了提高查询效率。

单表查询，可以直接使用逆向工程生成的mapper。

### Service层

功能分析：接收controller传递过来的item对象，并根据这个对象把不为空的字段都补全（比如生成商品id），然后向item表中插入数据。

参数：TbItem

返回值：TaotaoResult

```java
// 接受controller传递过来的TbItem对象，然后根据这个对象把不为空的字段补全，最后向item表中插入数据
// com.taotao.service.impl.ItemServiceImpl.addItem(TbItem)

	@Override
	public TaotaoResult addItem(TbItem item) {
		try {
			//生成商品id
			//可以使用redis的自增长key，在没有redis之前使用时间+随机数策略生成
			Long itemId = IDUtils.genItemId();
			//补全不完整的字段
			item.setId(itemId);
			item.setStatus((byte) 1);
			Date date = new Date();
			item.setCreated(date);
			item.setUpdated(date);
			//把数据插入到商品表
			itemMapper.insert(item);
			
		} catch (Exception e) {
			e.printStackTrace();
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
		
		return TaotaoResult.ok();
	}
```

### Controller层

```java
// 功能分析：接收页面传递过来的数据包括商品和商品描述。
// 参数：TbItem。
// 返回值：TaotaoResult
// com.taotao.controller.ItemController.addItem(TbItem)

	@RequestMapping("/item/save")
	@ResponseBody
	public TaotaoResult addItem(TbItem item) {
		TaotaoResult result = itemService.addItem(item);
		return result;
	}
```

## 商品描述的添加

### 需求分析

后台要接收前台页面提交的商品信息，及商品描述；商品信息保存的同时还要保存商品描述。并且再数据库中商品信息和商品描述也是分开存储的，这样便于修改。

商品描述：html文档元素；

### Service层

```java
// com.taotao.service.impl.ItemServiceImpl
// 与上面相比多了商品描述的添加

	@Autowired
	private TbItemMapper itemMapper;
	@Autowired
	private TbItemDescMapper itemDescMapper;
	@Override
	public TaotaoResult addItem(TbItem item, String desc) throws Exception{
		//生成商品id
		//可以使用redis的自增长key，在没有redis之前使用时间+随机数策略生成
		Long itemId = IDUtils.genItemId();
		//补全不完整的字段
		item.setId(itemId);
		item.setStatus((byte) 1);
		Date date = new Date();
		item.setCreated(date);
		item.setUpdated(date);
		//把数据插入到商品表
		itemMapper.insert(item);
		//添加商品描述信息
		TaotaoResult result = insertItemDesc(itemId, desc);
		if (result.getStatus() != 200) {
			throw new Exception();
		}
		return TaotaoResult.ok();
	}

	private TaotaoResult insertItemDesc(Long itemId, String desc) {
		TbItemDesc itemDesc = new TbItemDesc();
		itemDesc.setItemId(itemId);
		itemDesc.setItemDesc(desc);
		itemDesc.setCreated(new Date());
		itemDesc.setUpdated(new Date());
		itemDescMapper.insert(itemDesc);
		return TaotaoResult.ok();
	}
```

### Controller层

```java
// com.taotao.controller.ItemController
// 比商品添加多了商品描述的添加功能

	@RequestMapping(value="/item/save", method=RequestMethod.POST)
	@ResponseBody
	public TaotaoResult addItem(TbItem item, String desc) throws Exception {
		TaotaoResult result = itemService.addItem(item, desc);
		return result;
	}
```

# 商品规格参数

## 数据库存储

数据库中有两个表：规格参数模板表、商品的规格参数表；

优点：

1、不需要做多表管理。

2、如果要求新添加的商品规格项发生改变，之前的商品不变是很简单的。

缺点：

复杂的表单和json之间的转换。对js的编写要求很高。

## 添加商品规格参数模板

业务逻辑：在规格参数界面选择类目后可以为不同的类目新增规格参数模板（同一个类目的商品具有同一个规格参数模板）；

选择商品分类后根据选择的商品分类到tb_item_param规格参数模板表中取规格模板，取到了说明此商品分类的规格模板已经添加提示不能添加，如果没有取得则正常添加。

### 需求分析

请求的url：/item/param/query/itemcatid/{itemCatId}

### Dao层

从tb_item_param表中根据商品分类id查询内容，这是单表操作，可以使用逆向工程的代码。

### Service层

功能：接收商品分类id，调用mapper查询tb_item_param表，返回结果TaotaoResult。

```java
// com.taotao.service.impl.ItemParamServiceImpl

@Service
public class ItemParamServiceImpl implements ItemParamService {

	@Autowired
	private TbItemParamMapper itemParamMapper;

	
	@Override
	public TaotaoResult getItemParamByCid(long cid) {
		TbItemParamExample example = new TbItemParamExample();
		Criteria criteria = example.createCriteria();
		criteria.andItemCatIdEqualTo(cid);
		List<TbItemParam> list = itemParamMapper.selectByExampleWithBLOBs(example);
		//判断是否查询到结果
		if (list != null && list.size() > 0) {
			return TaotaoResult.ok(list.get(0));
		}
		
		return TaotaoResult.ok();
	}
}
```

### Controller层

接收cid参数，调用Service查询规格参数模板，返回TaotaoResult，最后返回json数据。

```java
@Controller
@RequestMapping("/item/param")
public class ItemParamController {

	@Autowired
	private ItemParamService itemParamService;
	
	@RequestMapping("/query/itemcatid/{itemCatId}")
	@ResponseBody
	public TaotaoResult getItemParamByCid(@PathVariable Long itemCatId) {
		TaotaoResult result = itemParamService.getItemParamByCid(itemCatId);
		return result;
	}

}
```

## 提交商品规格参数模板

### 需求分析

首先把页面中所有文本框中的内容转换成json数据。把json字符串提交给后台。保存到规格参数表中。

### Dao层

保存规格参数模板，向tb_item_param表添加一条记录。可以使用逆向工程生成的代码。

### Service层

功能：接收TbItemParam对象，把对象调用mapper插入到tb_item_param表中，最后返回TaotaoResult。

```java
// com.taotao.service.impl.ItemParamServiceImpl
	@Override
	public TaotaoResult insertItemParam(TbItemParam itemParam) {
		//补全pojo
		itemParam.setCreated(new Date());
		itemParam.setUpdated(new Date());
		//插入到规格参数模板表
		itemParamMapper.insert(itemParam);
		return TaotaoResult.ok();
	}
```

### Controller层

功能：接收cid、规格参数模板，创建一TbItemParam对象，并调用Service返回TaotaoResult，最后返回json数据。

```java
// com.taotao.controller.ItemParamController
	@RequestMapping("/save/{cid}")
	@ResponseBody
	public TaotaoResult insertItemParam(@PathVariable Long cid, String paramData) {
		//创建pojo对象
		TbItemParam itemParam = new TbItemParam();
		itemParam.setItemCatId(cid);
		itemParam.setParamData(paramData);
		TaotaoResult result = itemParamService.insertItemParam(itemParam);
		return result;
	}
```

##  根据规格参数模板生成表单

在商品添加功能中，读取此商品对应的规格模板，生成表单。供使用者添加规格参数。

Service层的修改：

```java
// com.taotao.service.impl.ItemParamServiceImpl
	@Override
	public TaotaoResult getItemParamByCid(long cid) {
		TbItemParamExample example = new TbItemParamExample();
		Criteria criteria = example.createCriteria();
		criteria.andItemCatIdEqualTo(cid);
		List<TbItemParam> list = itemParamMapper.selectByExampleWithBLOBs(example);
		//判断是否查询到结果
		if (list != null && list.size() > 0) {
			return TaotaoResult.ok(list.get(0));
		}
		
		return TaotaoResult.ok();
	}
```

##  保存商品的规格参数

### 需求分析

提交表单之前，先把规格参数表单中的内容转换成json数据然后跟商品基本信息、商品描述同时提交给后台。保存至数据库。

主要是item_add.jsp中的修改；

### Dao层

需要向tb_item_param_item表中添加数据。

### Service层

接收规格参数的内容，和商品id，拼装成pojo调用mapper 的方法tb_item_param_item表中添加数据返回TaotaoResult。

```java
// com.taotao.service.impl.ItemServiceImpl

	@Override
	public TaotaoResult insertItemParamItem(Long itemId, String itemParam) {
		//创建一个pojo
		TbItemParamItem itemParamItem = new TbItemParamItem();
		itemParamItem.setItemId(itemId);
		itemParamItem.setParamData(itemParam);
		itemParamItem.setCreated(new Date());
		itemParamItem.setUpdated(new Date());
		//向表中插入数据
		itemParamItemMapper.insert(itemParamItem);
		
		return TaotaoResult.ok();
		
	}
```

### Controller层

```java
// com.taotao.controller.ItemController

	@RequestMapping(value="/item/save", method=RequestMethod.POST)
	@ResponseBody
	public TaotaoResult addItem(TbItem item, String desc, String itemParams) throws Exception {
		TaotaoResult result = itemService.addItem(item, desc, itemParams);
		return result;
	}
```

## 展示规格参数

当现实商品详情页面时，需要把商品的规格参数根据商品id取出来，生成html展示到页面。（本节只需要通过网址发送商品id显示规格参数即可）

### Dao层

根据商品id查询规格参数，单表查询，使用逆向工程生成的文件。

### Service层

接收商品id查询规格参数表。根据返回的规格参数生成html返回html。

```java
// com.taotao.service.impl.ItemParamItemServiceImpl

@Service
public class ItemParamItemServiceImpl implements ItemParamItemService {

	@Autowired
	private TbItemParamItemMapper itemParamItemMapper;
	
	@Override
	public String getItemParamByItemId(Long itemId) {
		//根据商品id查询规格参数
		TbItemParamItemExample example = new TbItemParamItemExample();
		Criteria criteria = example.createCriteria();
		criteria.andItemIdEqualTo(itemId);
		//执行查询
		List<TbItemParamItem> list = itemParamItemMapper.selectByExampleWithBLOBs(example);
		if (list == null || list.size() == 0) {
			return "";
		}
		//取规格参数信息
		TbItemParamItem itemParamItem = list.get(0);
		String paramData = itemParamItem.getParamData();
		//生成html
		// 把规格参数json数据转换成java对象
		List<Map> jsonList = JsonUtils.jsonToList(paramData, Map.class);
		StringBuffer sb = new StringBuffer();
		sb.append("<table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"1\" class=\"Ptable\">\n");
		sb.append("    <tbody>\n");
		for(Map m1:jsonList) {
			sb.append("        <tr>\n");
			sb.append("            <th class=\"tdTitle\" colspan=\"2\">"+m1.get("group")+"</th>\n");
			sb.append("        </tr>\n");
			List<Map> list2 = (List<Map>) m1.get("params");
			for(Map m2:list2) {
				sb.append("        <tr>\n");
				sb.append("            <td class=\"tdTitle\">"+m2.get("k")+"</td>\n");
				sb.append("            <td>"+m2.get("v")+"</td>\n");
				sb.append("        </tr>\n");
			}
		}
		sb.append("    </tbody>\n");
		sb.append("</table>");
		return sb.toString();
	}

}
```

### Controller层

接收商品id调用Service查询规格参数信息，得到规格参数的html。返回一个逻辑视图。把html展示到页面。

```java
@Controller
public class ItemParamItemController {

	@Autowired
	private ItemParamItemService itemParamItemService;
	
	@RequestMapping("/showitem/{itemId}")
	public String showItemParam(@PathVariable Long itemId, Model model) {
		String string = itemParamItemService.getItemParamByItemId(itemId);
		model.addAttribute("itemParam", string);
		return "item";
	}
}
```

# 前台系统搭建

## 前台系统系统架构

在互联网系统开发当中，我们一般都是采用了分层的方式来架构系统，但是为什么我们需要分层进行架构呢？

采用分层架构有利于系统的维护，系统的扩展。这其实就是系统的可维护性和可扩展性。分层就是按照功能把系统切分细分，细分之后就能分布式部署，就能引入伸缩性，就能提高性能。

好处：

1、基于soa理念将服务层抽出对外提供服务

2、可以实现灵活的分布式部署

## 搭建服务系统

服务形式：对外提供rest形式的服务，供其他系统调用。使用http协议传递json数据。

### 使用的技术

1、Mybatis

2、spring

3、springmvc

### 创建maven工程

### Pom文件

### web.xml

### 整合ssm

### Tomcat插件配置

### 安装taotao-manager到本地仓库

## 商品分类展示

### 需求分析

首页左侧有一个商品分类。当鼠标分类上，需要展示出此分类下的子分类。

当鼠标滑动到连接上触发mousemove事件，页面做一个ajax请求，请求json数据包含分类信息，得到json数据后初始化分类菜单并展示。

taotao-portal的前端代码文件是从京东上拷下来的，可以使用浏览器的审查元素来观察请求发送的url或代码在文件中的位置。

### Json数据

在webapp下建立一个category.json文件，将分类json数据放进去，这时候使用http://localhost:8082/category.json可以访问这个json文件。

### 使用ajax访问本工程的json数据

将js中的getJson的参数URL_Serv设置为http://localhost:8082/category.json，然后启动taotao-rest服务，就可以使用商品分类展示的功能了。

### Ajax跨域请求

这是另一种商品分类展示的方法，由客户端直接访问taotao-rest来显示商品分类。

Js是不能跨域请求的，出于安全考虑，js设计时不可以跨域。

什么是跨域：

1、域名不同时。

2、域名相同，端口不同。

只有域名相同、端口相同时，才可以访问；可以使用jsonp解决跨域问题。

### 什么是jsonp

Jsonp其实就是一个跨域解决方案。Js跨域请求数据是不可以的，但是js跨域请求js脚本是可以的。可以把数据封装成一个js语句，做一个方法的调用。跨域请求js脚本可以得到此脚本。得到js脚本之后会立即执行。可以把数据做为参数传递到方法中。就可以获得数据。从而解决跨域问题。

### jsonp的原理

浏览器在js请求中，是允许通过script标签的src跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，既可获取到跨域请求的数据。

### 跨域请求的实现

将category.json文件放到taotao-rest下，这时候可以通过http://localhost:8081/category.json访问；在js中使用getJsonp方法，并将json数据改为js脚本。

### 从数据库中取商品分类列表

相比之前在category.json中定义的静态商品分类数据，这里从数据库取动态的商品分类列表，在首页展示的效果是类似的。

# 后台内容管理

## 删除节点

### 需求分析

请求的url：/content/category/delete/

参数：Id（从jsp中获取）

返回值：TaotaoResult

### Dao层

在mapper xml文件中添加以下的查询语句：

根据parentId删除

```sql
  <delete id="deleteByParentId" parameterType="java.lang.Long">
  	delete from tb_content_category
  	where parent_id=#{id,jdbcType=BIGINT}
  </delete>
```

根据parentId查询父结点的子节点个数

```sql
  <select id="countByParentId" parameterType="java.lang.Long" resultType="java.lang.Integer">
  	select count(*) from tb_content_category where parent_id=#{id ,jdbcType=BIGINT}
  </select>
```

其实可以直接使用逆向工程的精确查询，不过直接添加查询语句也很方便。

### Service层

这里有一个bug，对于拥有两层及以上的子节点的节点来说，如果直接将这个节点删除，那么只会删除它的第一层的子节点，而不会删除更下层的节点。这个问题待解决，用递归删除应该能解决。

```java
	@Override
	public TaotaoResult deleteContentCategory(long id) {
		// 获取当前节点的父结点id
		TbContentCategory contentCategory=contentCategoryMapper.selectByPrimaryKey(id);
		long parentId=contentCategory.getParentId();
		// 删除子结点
		contentCategoryMapper.deleteByPrimaryKey(id);
		contentCategoryMapper.deleteByParentId(id);
		// 统计父节点的子节点数，如果父节点没有子结点了，设置isParent为false
		int childNum = contentCategoryMapper.countByParentId(parentId);
		if (childNum == 0) {
			TbContentCategory parentCat = contentCategoryMapper.selectByPrimaryKey(parentId);
			parentCat.setIsParent(false);
			contentCategoryMapper.updateByPrimaryKey(parentCat);
		}

		return TaotaoResult.ok();
	}
```

### Controller层

```java
	@RequestMapping("/delete")
	@ResponseBody
	public TaotaoResult deleteContentCategory(Long id) {
		TaotaoResult result=contentCategoryService.deleteContentCategory(id);
		return result;
	}
```

## 内容列表查询展示

### 内容管理表

在数据库中创建内容管理表；

```sql
CREATE TABLE `tb_content` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `category_id` bigint(20) NOT NULL COMMENT '内容类目ID',
  `title` varchar(200) DEFAULT NULL COMMENT '内容标题',
  `sub_title` varchar(100) DEFAULT NULL COMMENT '子标题',
  `title_desc` varchar(500) DEFAULT NULL COMMENT '标题描述',
  `url` varchar(500) DEFAULT NULL COMMENT '链接',
  `pic` varchar(300) DEFAULT NULL COMMENT '图片绝对路径',
  `pic2` varchar(300) DEFAULT NULL COMMENT '图片2',
  `content` text COMMENT '内容',
  `created` datetime DEFAULT NULL,
  `updated` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  KEY `updated` (`updated`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8;
```

### 需求分析

**数据库查询语句**：SELECT * from tb_content where id=#{categoryId}

**请求的url**：/content/query/list

**请求参数**：http://localhost:8080/content/query/list?categoryId=117&page=1&rows=20  

包含内容类别id：categoryId（对应内容页的id）；分页信息：page和rows；

根据categoryId从tb_content下找到所有categoryId等于传进来的categoryId参数的广告；

**响应的数据格式**：EasyUIResult

### Dao层

使用分页插件，分页插件在商品列表展示的地方配置过滤，这里只要直接使用。

### Service层

接收分页参数，一个是page一个是rows，然后根据这些参数和categoryId调用dao查询内容列表并分页，最后返回内容列表。

Easyui中datagrid控件要求的数据格式为json格式：{total:”2”,rows:[{“id”:”1”,”name”,”张三”},{“id”:”2”,”name”,”李四”}]}，所以我们需要创建一个Pojo来返回一个EasyUIDateGrid支持的json数据格式。这个pojo可能会被多个项目使用，所以此pojo应该放到taotao-common工程中。（在商品列表展示的过程中已经创建了这个pojo，所以不用再创建，直接使用）

```java
// 位于taotao-common/src/main/java/com.taotao.common.pojo

public class EUDataGridResult {

	private long total;
	private List<?> rows;
	public long getTotal() {
		return total;
	}
	public void setTotal(long total) {
		this.total = total;
	}
	public List<?> getRows() {
		return rows;
	}
	public void setRows(List<?> rows) {
		this.rows = rows;
	}
	
}
```

根据categoryId，page，rows参数去数据库中查询符合categoryId的内容，并封装成为EUDataGridResult类的形式，然后返回给Controller。

这里有一个bug，在子类中添加的内容不会在父类中查询到，因为它的categoryId和父类不同，如果要实现完整的功能需要递归查询。（暂时不实现了）

```java
// com.taotao.service.impl.ContentServiceImpl

@Autowired
private TbContentMapper tbContentMapper;

public EUDataGridResult getContentList(Long categoryId, int page, int rows) {
    // 设置查询 条件 categoryId
    TbContentExample example = new TbContentExample();
    Criteria criteria = example.createCriteria();
    criteria.andCategoryIdEqualTo(categoryId);
    // 查询前分页
    PageHelper.startPage(page, rows);
    // 按条件查询
    List<TbContent> list = tbContentMapper.selectByExample(example);
    // 将查询条件封装到EasyUI能接受的格式
    EUDataGridResult result = new EUDataGridResult();
    result.setRows(list);
    PageInfo<TbContent> info=new PageInfo<TbContent>(list);
    result.setTotal(info.getTotal());
    return result;
}
```

### Controller层

调用service层的方法，然后返回。

```java
@Controller
public class ContentController {
	
	@Autowired
	ContentService contentService;
	
	@RequestMapping("/content/query/list")
	@ResponseBody
	public EUDataGridResult getContentList(Long categoryId, int page ,int rows) {
		EUDataGridResult result=contentService.getContentList(categoryId, page, rows);
		return result;
	}

}
```

## 内容添加

### 需求分析

请求的url：/content/save

请求的方法：post

请求内容：表单中的内容。

返回的结果：TaotaoResult。

### Dao层

向tb_content表中插入数据。可以使用逆向工程生成的代码。

### Service层

接收表tb_content对应的pojo对象。把pojo对象插入到tb_content表中。

返回TaotaoResult。

```java
// com.taotao.service.impl.ContentServiceImpl
@Override
	public TaotaoResult addContent(TbContent content) {
		content.setCreated(new Date());
		content.setUpdated(new Date());
		tbContentMapper.insert(content);
		return TaotaoResult.ok();
	}
```

### Controller层

接收表单中的内容，使用pojo接收。要求pojo的属性要和表单中的name一致。调用Service插入内容信息。返回TaotaoResult。Json格式的数据。

从JSP传入的不是pojo对象，应该如何转换为pojo对象呢？（需要读JSP，待解决）

默认JSP传入的是TbContent对象。

```java
// com.taotao.controller.ContentController

@RequestMapping("content/save")
	@ResponseBody
	public TaotaoResult addContent(TbContent content) {
		TaotaoResult result=contentService.addContent(content);
		return result;
		
	}
```

# 展示商城首页大广告位

## 方案

系统直接服务的调用，需要使用httpclient来实现。Taotao-portal和taotao-rest是在同一个局域网内部。速度非常快，调用时间可以忽略不计。

![首页展示大广告位方案](https://i.ibb.co/GvbxWkD/image.png)

## 内容服务发布

### 需求分析

rest服务层连接数据库获取广告信息；

根据内容的分类id查询内容列表，从tb_content表中查询。服务是一个restFul形式的服务。使用http协议传递json格式的数据。

请求url：/rest/content/list/{contentCategoryId}（这个url有portal的调用方式决定）

### Dao层

从tb_content表中查询，根据内容分类id查询。是单表查询。可以使用逆向工程生成的代码。

### service层

接收内容分类id，根据分类id查询分类列表。返回一个内容pojo列表。

参数：分类id

返回值：pojo列表

```java
// com.taotao.rest.service.ContentServiceImpl
@Service
public class ContentServiceImpl implements ContentService{
	@Autowired
	TbContentMapper tbContentMapper;
	
	@Override
	public List<TbContent> getContent(Long categoryId){
		TbContentExample example=new TbContentExample();
		Criteria criteria=example.createCriteria();
		criteria.andCategoryIdEqualTo(categoryId);
		List<TbContent> list=tbContentMapper.selectByExample(example);
		return list;
	}
}
```

### Controller层

发布服务。接收查询参数。Restful风格内容分类id应该从url中取。

从url中取内容分类id，调用Service查询内容列表。返回内容列表。返回一个json格式的数据。可以使用TaotaoResult包装此列表。

```java
// com.taotao.rest.controller.ContentController

@Controller
@RequestMapping("/content")
public class ContentController {
	@Autowired
	ContentService contentService;
	
	@RequestMapping("/list/{contentCategoryId}")
	@ResponseBody
	public TaotaoResult getContent(@PathVariable Long contentCategoryId) {
		try {
			List<TbContent> list=contentService.getContent(contentCategoryId);
			return TaotaoResult.ok(list);
			
		} catch (Exception e) {
			e.printStackTrace();
            // 当查询不到文件的，抛出一个封装好的异常（使用了ExceptionUtil工具类）
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
	}
}

```

### 内容服务测试

使用java开发工具：restclient，可以发送get和post请求。

在restclient中访问http://localhost:8081/rest/content/list/89 可以获取返回信息。

## HttpClient的使用

### 什么是httpclient

HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。

### 添加依赖

```xml
		<!-- httpclient -->
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
		</dependency>
```

### 使用方法

使用httpclient将http请求用java代码封装起来，提供portal调用。

**使用httpclient执行get请求**

```java
// com.taotao.httpClient.HttpClientTest
	public void doGet() throws ClientProtocolException, IOException {
		// 创建一个httpClient对象
		CloseableHttpClient client=HttpClients.createDefault();
		// 创建一个Get对象
		HttpGet get=new HttpGet("http://www.baidu.com");
		// 执行请求
		CloseableHttpResponse response= client.execute(get);
		// 取响应的结果
		int statusCode=response.getStatusLine().getStatusCode();
		System.out.println(statusCode);
		HttpEntity httpEntity=response.getEntity();
		String s=EntityUtils.toString(httpEntity, "utf-8");
		System.out.println(s);
		response.close();
		client.close();
		
	}
```

**执行get请求带参数**

```java
// com.taotao.httpClient.HttpClientTest
	public void doGetWithParam() throws ClientProtocolException, IOException, URISyntaxException {
		// 创建一个httpClient对象
		CloseableHttpClient client=HttpClients.createDefault();
		// 创建一个uri对象
		URIBuilder builder=new URIBuilder("http://www.baidu.com/baidu");
		builder.addParameter("wd", "许嵩");
		// 创建一个Get对象
		HttpGet get=new HttpGet(builder.build());
		// 执行请求
		CloseableHttpResponse response= client.execute(get);
		// 取响应的结果
		int statusCode=response.getStatusLine().getStatusCode();
		System.out.println(statusCode);
		HttpEntity httpEntity=response.getEntity();
		String s=EntityUtils.toString(httpEntity, "utf-8");
		System.out.println(s);
		response.close();
		client.close();
	}
```

**使用httpclient执行post请求**

```java
// com.taotao.httpClient.HttpClientTest
	public void doPost() throws Exception {
		CloseableHttpClient httpClient = HttpClients.createDefault();
	
		//创建一个post对象
		HttpPost post = new HttpPost("http://localhost:8082/httpclient/post.html");
		//执行post请求
		CloseableHttpResponse response = httpClient.execute(post);
		String string = EntityUtils.toString(response.getEntity());
		System.out.println(string);
		response.close();
		httpClient.close();
		
	}
```

在Controller层添加一个post请求的响应来进行测试

```java
// com.taotao.portal.controller.IndexController
	@RequestMapping(value = "/httpclient/post", method =RequestMethod.POST)
	@ResponseBody
	public String testPost() {
		return "ok";
	}
```

**带参数post请求**

```java
// com.taotao.httpClient.HttpClientTest
	public void doPostWithParam() throws Exception{
		CloseableHttpClient httpClient = HttpClients.createDefault();
		
		//创建一个post对象
		HttpPost post = new HttpPost("http://localhost:8082/httpclient/post2.html");
		//创建一个Entity。模拟一个表单
		List<NameValuePair> kvList = new ArrayList<>();
		kvList.add(new BasicNameValuePair("username", "zhangsan"));
		kvList.add(new BasicNameValuePair("password", "123"));
		
		//包装成一个Entity对象
		StringEntity entity = new UrlEncodedFormEntity(kvList, "utf-8");
		//设置请求的内容
		post.setEntity(entity);
		
		//执行post请求
		CloseableHttpResponse response = httpClient.execute(post);
		String string = EntityUtils.toString(response.getEntity());
		System.out.println(string);
		response.close();
		httpClient.close();
	}

```

在Controller层添加一个post请求的响应来进行测试

```java
// com.taotao.portal.controller.IndexController
	@RequestMapping(value = "/httpclient/post2", method =RequestMethod.POST)
	@ResponseBody
	public String testPost2(String username, String password) {
		return "username:"+username+"\t"+"password:"+password;
	}
```

## 大广告位展示

### 需求分析

需要创建一个json字符串传递给jsp

Json字符串如何传递给jsp：使用modelAndView对象把json字符串传递给jsp。

如何获得json字符串：获得一个广告位对应的内容列表，需要调用taotao-rest的服务。把列表转换成json数据格式要求的pojo对象列表。

需要使用httpclient调用taotao-rest的服务。

```json
// 广告位需要的json字符串格式
{
    "srcB": "http://image.taotao.com/images/2015/03/03/2015030304360302109345.jpg",
    "height": 240,
    "alt": "",
    "width": 670,
    "src": "http://image.taotao.com/images/2015/03/03/2015030304360302109345.jpg",
    "widthB": 550,
    "href": "http://sale.jd.com/act/e0FMkuDhJz35CNt.html?cpdad=1DLSUE",
    "heightB": 240
}
```

jsp中需要传到前台的引用

```javascript
// index.jsp
var data = ${ad1};
```

### Service层

根据内容分类id查询分类的内容列表，需要使用httpclient调用taotao-rest的服务。得到一个json字符串。需要把字符串转换成java对象taotaoResult对象。从taotaoResult对象中取data属性，得到内容列表。把内容列表转换成jsp页面要求的json格式。返回一个json字符串。

参数：没有参数

返回值：json字符串。根据内容分类id查询分类的内容列表，需要使用httpclient调用taotao-rest的服务。得到一个json字符串。需要把字符串转换成java对象taotaoResult对象。从taotaoResult对象中取data属性，得到内容列表。把内容列表转换成jsp页面要求的json格式。返回一个json字符串。

参数：没有参数

返回值：json字符串。

```java
// com.taotao.portal.service.ContentServiceImpl
@Service
public class ContentServiceImpl implements ContentService{
	@Value("${REST_BASE_URL}")
	private String REST_BASE_URL;
	@Value("${REST_INDEX_AD_URL}")
	private String REST_INDEX_AD_URL;
	@Override
	public String getContentList() {
		// 调用服务层的服务
		String result=HttpClientUtil.doGet(REST_BASE_URL+REST_INDEX_AD_URL);
		// 把字符串转换为taotaoresult
		try {
			TaotaoResult taotaoResult=TaotaoResult.formatToList(result, TbContent.class);
			List<TbContent> list=(List<TbContent>) taotaoResult.getData();
			List<Map> resultList=new ArrayList<Map>();
			for(TbContent content:list) {
				Map map=new HashMap<>();
				map.put("src",content.getPic());
				map.put("height",240);
				map.put("width",670);
				map.put("heightB",240);
				map.put("widthB", 550);
				map.put("srcB", content.getPic2());
				map.put("href",content.getUrl());
				map.put("alt", content.getSubTitle());
				resultList.add(map);
			}
			return JsonUtils.objectToJson(resultList);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
}
```

### Controller层

```java
	@RequestMapping("/index")
	public String showIndex(Model model) {
		String adJson = contentService.getContentList();
		model.addAttribute("ad1", adJson);
		
		return "index";
	}
```

# redis缓存

## redis介绍

redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。

### gcc环境

安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install -y gcc-c++

安装位置：使用yum安装，对于不同的软件有不同的安装位置。

本教程使用redis3.0版本，3.0版本主要增加了redis集群功能。

### 安装

将redis源码包上传到linux服务器，然后解压、编译和安装；

- 将redis-3.0.0.tar.gz拷贝到/usr/local下；
- 解压：tar -zxvf redis-3.0.0.tar.gz；
- 编译：cd /usr/local/redis-3.0.0  make；
- 安装：安装到指定目录cd /usr/local/redis-3.0.0 make PREFIX=/usr/local/redis install；

### 启动

前端模式启动：./redis-server；前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。

后端模式启动：在redis解压的包中找到redis.conf，然后拷到redis安装文件夹中，修改redis.conf配置文件， daemonize yes 以后端模式启动。执行如下命令启动redis：cd /usr/local/redis；./bin/redis-server；./redis.conf

查看是否启动成功：ps aux|grep redis

### 测试

启动redis客户端 ./redis-cli

常用测试命令：ping；set a 10；get a；

## redis集群

### redis-cluster架构

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
- 节点的fail是通过集群中超过半数的节点检测失效时才生效。redis-cluster投票:容错
- 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
- redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value
- Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点
- 什么时候整个集群不可用(cluster_state:fail)? a:如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态. ps : redis-3.0.0.rc1加入cluster-require-full-coverage参数,默认关闭,打开集群兼容部分失败.b:如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.

> ps:当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误

### 我们的集群架构

  集群中有三个节点的集群，每个节点有一主一备，需要6台虚拟机。搭建一个伪分布式的集群，使用6个redis实例来模拟。

### 搭建集群需要的环境

搭建集群需要使用官方提供的ruby脚本，需要安装ruby的环境。

> rubygems：ruby的包管理器；

安装ruby：yum install ruby；yum install rubygems；

> redis集群管理工具redis-trib.rb（ruby脚本）：位于redis安装包的src里面；

redis集群管理工具所依赖的ruby包：redis-3.0.0.gem；上传到服务器的/usr/local/下，执行gem install redis-3.0.0.gem

### 搭建集群

（1）在/usr/local/下建立一个空文件夹redis-cluster，然后将redis的bin文件夹内容复制到该文件下的redis01文件夹中

```
cp -r bin ../redis-cluster/redis01
```

删除redis01下的redis持久化文件dump.rdb，并修改配置文件redis.conf中的端口号为7001，并打开cluster-enabled。如法炮制总共6个redis文件夹。

（2）把创建集群的ruby脚本拷贝到redis-cluster下

（3）启动六个redis实例：可以创建一个脚本，startall.sh

```sh
  cd redis01
  ./redis-server redis-conf
  cd ..
  cd redis02
  ./redis-server redis-conf
  cd ..
  cd redis03
  ./redis-server redis-conf
  cd ..
  cd redis04
  ./redis-server redis-conf
  cd ..
  cd redis05
  ./redis-server redis-conf
  cd ..
  cd redis06
  ./redis-server redis-conf
  cd ..
```

改变脚本的运行权限：

```
chmod +x startall.sh
```

然后启动脚本：

```
./startall.sh
```

检查redis的启动情况：

```
ps aux|grep redis
```

（4）创建集群

执行命令：

```sh
 ./redis-trib.rb create --replicas 1 192.168.222.128:7001 192.168.222.128:7002 192.168.222.128:7003 192.168.222.128:7004 192.168.222.128:7005  192.168.222.128:7006
```

### 测试集群

```
redis01/redis-cli -h 192.168.222.128 -p 7002 -c
```

redis-cli表示redis客户端

### 关闭redis

单机版：在redis-cli中执行命令shutdown

集群：bin/redis-cli -p 7001 shutdown

可以写一个关闭脚本shutdown.sh

## redis客户端

### 自带客户端

redis-cli

### 图形化客户端

Redis Desktop Manager 只支持单机版，不支持集群；

redis有16个库，库的个数可以在redis-conf中设置；集群版只有一个库；

### Jedis客户端

（1）单机版

导入jedis客户端，使用maven加入redis客户端的坐标。

通过创建单实例jedis对象连接redis服务；

```java
//com.taotao.rest.jedis.TestJedisSingle

	public void testJedisSingle() {
		Jedis jedis=new Jedis("192.168.222.128", 6379);
		jedis.set("name","jack");
		String name=jedis.get("name");
		System.out.println(name);
		jedis.close();
	}
```

使用连接池连接

```java
//com.taotao.rest.jedis.TestJedisSingle

	public void pool() {
		JedisPool jedisPool=new JedisPool("192.168.222.128", 6379);
		Jedis jedis=jedisPool.getResource();
		jedis.set("student","mary");
		String name=jedis.get("student");
		System.out.println(name);
		jedis.close();
		jedisPool.close();
	}
```

（2）集群版

```java
//com.taotao.rest.jedis.TestJedisSingle

	public void testJedisCluster() {
		HashSet<HostAndPort> set=new HashSet<HostAndPort>();
		set.add(new HostAndPort("192.168.222.128", 7001));
		set.add(new HostAndPort("192.168.222.128", 7002));
		set.add(new HostAndPort("192.168.222.128", 7003));
		set.add(new HostAndPort("192.168.222.128", 7004));
		set.add(new HostAndPort("192.168.222.128", 7005));
		set.add(new HostAndPort("192.168.222.128", 7006));
		JedisCluster cluster=new JedisCluster(set);
		cluster.set("key1","2");
		String key1=cluster.get("key1");
		System.out.println(key1);
		cluster.close();
	}
```

## 业务逻辑中添加缓存

### 业务逻辑

接受到一个用户请求，先根据key（内容分类id）到redis中去查， 查得到直接返回，查不到再到mysql中寻找，放入redis中并返回结果；

需要在taotao-rest工程中添加缓存；

### Jedis整合spring

单机版整合：将JedisPool整合到spring里面；

bean的配置文件：

```xml
<!--applicationContext-jedis.xml-->

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<bean id="redisClient" class="redis.clients.jedis.JedisPool">
	<constructor-arg name="host" value="192.168.222.128"></constructor-arg>
	<constructor-arg name="port" value="6379"></constructor-arg>
</bean>

</beans>
```

测试：

```java
//com.taotao.rest.jedis.TestJedisSingle

	public void testSpringSingle() {
		ApplicationContext applicationContext=new ClassPathXmlApplicationContext("classpath:spring/applicationContext-jedis.xml");
		JedisPool jedisPool=(JedisPool) applicationContext.getBean("redisClient");
		Jedis jedis=jedisPool.getResource();
		jedis.set("spring","bingo");
		System.out.println(jedis.get("student"));
		jedis.close();
		jedisPool.close();
	}
```

### 添加jedis Service

将jedis的操作封装起来

```java
// com.taotao.rest.service.RedisServiceImpl
	public class RedisServiceImpl implements RedisService {
	@Autowired
	JedisPool jedisPool;

	@Override
	public String get(String key) {
		Jedis jedis=jedisPool.getResource();
		String result=jedis.get(key);
		jedis.close();
		return result;
	}

	@Override
	public String set(String key1, String value) {
		Jedis jedis=jedisPool.getResource();
		String result=jedis.set(key1,value);
		jedis.close();
		return result;
	}

	@Override
	public long hset(String hkey, String key, String value) {
		Jedis jedis=jedisPool.getResource();
		long result=jedis.hset(hkey,key,value);
		jedis.close();
		return result;
	}

	@Override
	public String hget(String hkey, String key) {
		Jedis jedis=jedisPool.getResource();
		String result=jedis.hget(hkey,key);
		jedis.close();
		return result;
	}

	@Override
	public long incr(String key) {
		Jedis jedis=jedisPool.getResource();
		long result=jedis.incr(key);
		jedis.close();
		return result;
	}

	@Override
	public long expire(String key,int seconds) {
		Jedis jedis=jedisPool.getResource();
		long result=jedis.expire(key, seconds);
		jedis.close();
		return result;
	}

	@Override
	public long ttl(String key) {
		Jedis jedis=jedisPool.getResource();
		long result=jedis.ttl(key);
		jedis.close();
		return result;
	}

}
```

### 把缓存添加到业务逻辑

修改获取大广告的业务逻辑

```java
@Service
public class ContentServiceImpl implements ContentService{
	@Autowired
	TbContentMapper tbContentMapper;
	@Autowired
	RedisService redisService;
	@Value(value = "${CONTENT_REDIS}")
	private String CONTENT_REDIS;
	@Override
	public List<TbContent> getContent(Long categoryId){
		// 从redis中取广告
		try {
			String result=redisService.hget(CONTENT_REDIS, categoryId+"");
			if(!StringUtils.isBlank(result)) {
				List<TbContent> list=JsonUtils.jsonToList(result, TbContent.class);
				return list;
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 根据大广告分类id从mysql中取广告
		TbContentExample example=new TbContentExample();
		Criteria criteria=example.createCriteria();
		criteria.andCategoryIdEqualTo(categoryId);
		List<TbContent> list=tbContentMapper.selectByExample(example);

		
		// 向redis中添加内容
		try {
			String json = JsonUtils.objectToJson(list);
			redisService.hset(CONTENT_REDIS, categoryId+"", json);
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return list;
	}
}
```

## 缓存同步

当后台管理系统，修改内容之后需要通知redis把修改的内容对应的分类id的key删除。

### 添加缓存后的系统架构

后台管理修改mysql，然后调用rest服务，删除对应的缓存。

### 解决方案

在taotao-rest工程中发布一个服务。当后台管理系统修改内容后，调用此服务，同步缓存。

### Dao层

使用JedisClient接口对应的实现类。

添加删除key和hkey的功能

```java
// com.taotao.rest.service.RedisServiceImpl.hdel(String, String)
	@Override
	public long hdel(String hkey,String key) {
		Jedis jedis=jedisPool.getResource();
		long result=jedis.hdel(hkey, key);
		jedis.close();
		return result;
	}
```

### Service层

接收内容分类id，调用dao删除redis中对应的hash中key为分类id的项。

参数：内容分类id

返回值：TaotaoResult

```java
// com.taotao.rest.service.CacheSyncServiceImpl
@Service
public class CacheSyncServiceImpl implements CacheSyncService{
	@Autowired
	private RedisService redisService;
	@Value(value = "${CONTENT_REDIS}")
	private String CONTENT_REDIS;
	@Override
	public TaotaoResult syncContent(long categoryId) {
		try {
			redisService.hdel(CONTENT_REDIS, categoryId+"");
		} catch (Exception e) {
			e.printStackTrace();
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
		return TaotaoResult.ok();
	}
}
```

### Controller层

接收内容分类id，调用Service返回taotaoResult。

```java
// com.taotao.rest.controller.CacheSyncController

@Controller
@RequestMapping("/cache/sync")
public class CacheSyncController {
	@Autowired
	CacheSyncService cacheSyncService;
	@RequestMapping("/content/{categoryId}")
	public TaotaoResult syncContent(@PathVariable long categoryId) {
		TaotaoResult result=cacheSyncService.syncContent(categoryId);
		return result;
	}
}
```

## 同步缓存服务的调用

需要在后台管理系统中添加一个服务调用的逻辑。当修改内容信息后，需要调用此服务同步缓存。

http调用的rest的url的配置

```properties
# /taotao-manager-web/src/main/resources/Properties/resource.properties
CACHE_SYNC_BASE_URL=http://localhost:8081/rest
CONTENT_URL=/cache/sync/content/
```

```java
// com.taotao.service.impl.ContentServiceImpl
	@Override
	public TaotaoResult addContent(TbContent content) {
		content.setCreated(new Date());
		content.setUpdated(new Date());
		tbContentMapper.insert(content);
		
		// 添加用于同步缓存的语句
		try {
			HttpClientUtil.doGet(CACHE_SYNC_BASE_URL+CONTENT_URL+content.getCategoryId());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return TaotaoResult.ok();
	}
```

# 搜索服务

## Solr实现全文搜索

### Solr是什么？

Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 

Solr是一个全文检索服务器，只需要进行配置就可以实现全文检索服务。

## Solr的安装及配置

Solr的版本：4.10.3

### 安装步骤

需要把solr服务器安装到linux环境

**第一步：安装linux、jdk、tomcat。**

```
tar -zxf apache-tomcat-7.0.47.tar.gz 
mkdir /usr/local/solr
cp apache-tomcat-7.0.47 /usr/local/solr/tomcat -r
cd /usr/local/solr/
```

> cp apache-tomcat-7.0.47 /usr/local/solr/tomcat 会出现略过apache-tomcat-7.0.47，需要使用cp apache-tomcat-7.0.47 /usr/local/solr/tomcat -r

现在tomcat已经放在/usr/local/solr/tomcat文件下了。

**第二步：把solr的压缩包上传到服务器的opt文件夹中。并解压。**

```
tar -zxf solr-4.10.3.tgz.tgz 
```

**第三步：把/opt/solr-4.10.3/dist/solr-4.10.3.war包部署到tomcat下。并改名为solr.war**

> solr软件包下面的文件的作用：
>
> bin：里面是一些可执行命令，用来单独演示solr时使用，默认在jetty容器中运行
>
> contrib：包含一些扩展包
>
> dist：里面有一个war包，这个包就是一个solr工程，用来部署到tomcat下。
>
> docs：文档
>
> example：一些实例，其中webapps下面的solr.war包和dist下的war包是完全一样的，而solr文件夹则是一个标准的solrhome，里面的collection1/conf文件夹下放有所有的配置文件，其中schema.xml文件定义了字段、field、fieldtype等配置，在后面配置中文分析器时要用到；solrconfig.xml则是其他的一些配置。

bin：有一些solr的命令，当只需要单独演示solr功能的时候使用，solr将默认运行在jetty里面；

dist：所有编译完生成的文件（jar包、war包）都放在这个包下，其中有一个war包，就是solr工程，可以运行在web容器中；

contrib：一些扩展包

docs：文档

example：很多solr的实例，其中有一个文件solr，就是一个标准的solrhome，其中的collection1下面有一个conf文件夹，所有的配置文件都放在这个文件夹下。其中schema.xml配置字段、field和fieldtype，后面配置中文分析器也需要修改这个文件，solrconfig.xml则用来配置其他的一些选项；

webapps：里面的solr.war和dist里面的war包是完全一样的。

```
cp solr-4.10.3.war /usr/local/solr/tomcat/webapps/solr.war
```

**第四步：解压war包。启动tomcat自动解压。关闭tomcat。删除solr.war.**

启动tomcat：在tomcat安装位置下

```
bin/startup.sh
```
查看日志，看tomcat是否已经启动
```
tail -f logs/catalina.out
```
启动tomcat后，部署在里面的war包会自动解压，本次启动tomcat的目的就是解压war包，所以启动成功后就关闭tomcat
```
bin/shutdown.sh
```
关闭tomcat后，进入webapps文件夹，可以看到solr.war解压后的solr文件夹，这时候就可以将war包删掉了。
```
rm -f solr.war
```

**第五步：把/opt/solr-4.10.3/example/lib/ext目录下所有的jar包复制到solr工程中。**

这些都是日志相关的jar包

```
cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/
```

**第六步：创建solrhome。Solrhome是存放solr服务器所有配置文件的目录。**

```
cp -r solr /usr/local/solr/solrhome
```

**第七步：告诉solr服务器solrhome的位置。需要修改solr工程的web.xml文件。**

找到web.xml，并修改
```
cd tomcat/webapps/solr/WEB-INF/
vim web.xml
```
修改目录位置
```
<env-entry-value>/usr/local/solr/solrhome</env-entry-value>
```

**第八步：启动tomcat**

在浏览器中输入（solr工程我们之前已经放在webapps文件下了，可以直接访问）

```
192.168.222.128:8080/solr
```

### 配置业务字段

在Solr中默认是没有中文分析器的，需要手工配置，配置一个FieldType，在FieldType中指定使用的中文分析器。另外，Solr中的字段(即业务域)必须先定义后使用。

Solr中的字段必须是先定义后使用。

**中文分析器的配置**

第一步：使用IK-Analyzer。把分析器的文件夹上传到服务器。

> 包中的主要文件：
>
> doc：IK Analyzer的文档。
>
> ext_stopword.dic：停用词词典。在信息检索中，为节省存储空间和提高搜索效率，在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词，这些字或词即被称为Stop Words（停用词）。这些停用词都是人工输入、非自动化生成的，生成后的停用词会形成一个停用词表。但是，并没有一个明确的停用词表能够适用于所有的工具，甚至有一些工具是明确地避免使用停用词来支持短语搜索的。
>
> IKAnalyzer.cfg.xml：配置文件。
>
> mydict.dic：扩展词典。

第二步：需要把分析器的jar包添加到solr工程中。

```
cp IKAnalyzer2012FF_u1.jar /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/
```

第三步：需要把IKAnalyzer需要的扩展词典及停用词词典、配置文件复制到solr工程的classpath。

```
cd /usr/local/solr/tomcat/webapps/solr/WEB-INF/
mkdir classes
```

```
cp IKAnalyzer.cfg.xml ext_stopword.dic mydict.dic /usr/local/solr/tomcat/webapps/solr/WEB-INF/classes
```

扩展词典及停用词词典的字符集必须是utf-8。不能使用windows记事本编辑。

第四步：配置fieldType。需要在solrhome/collection1/conf/schema.xml中配置。

技巧：使用vi、vim跳转到文档开头gg。跳转到文档末尾：G

```xml
<fieldType name="text_ik" class="solr.TextField">
  <analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/>
</fieldType>
```

**业务字段配置**

业务字段判断标准：

1、在搜索时是否需要在此字段上进行搜索。例如：商品名称、商品的卖点、商品的描述

2、后续的业务是否需要用到此字段。例如：商品id。

需要用到的字段：

1、商品id

2、商品title

3、卖点

4、价格

5、商品图片

6、商品分类名称

7、商品描述

Solr中的业务字段：

id->商品id

其他的对应字段创建solr的字段。字段的stored代表是否存储字段，是否存储的判断标准是字段在搜索时是否需要展示给用户。

我们配置完业务域后，还要配置复制域，即在schema.xml的末尾添加复制域，如下所示，复制域的好处是可以提高查询效率，原来需要查询多个字段的，现在只需要查询一个字段就可以了（因为各个字段都把内容复制到一块儿了，查询也就方便了）。

```xml
<field name="item_title" type="text_ik" indexed="true" stored="true"/>
<field name="item_sell_point" type="text_ik" indexed="true" stored="true"/>
<field name="item_price"  type="long" indexed="true" stored="true"/>
<field name="item_image" type="string" indexed="false" stored="true" />
<field name="item_category_name" type="string" indexed="true" stored="true" />
<field name="item_desc" type="text_ik" indexed="true" stored="false" />

<field name="item_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/>
<copyField source="item_title" dest="item_keywords"/>
<copyField source="item_sell_point" dest="item_keywords"/>
<copyField source="item_category_name" dest="item_keywords"/>
<copyField source="item_desc" dest="item_keywords"/>
```

将以上字段写到schema.xml文件中，之后重新启动tomcat，中文分析器就配置好了。

**中文分析器**

IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包，结合词典分词和文法分析算法的中文分词组件。

## 维护索引库

**添加索引**

在Documents中添加一个json格式的文件就可以。

测试例子：

```
"id":"test001","item_title":"测试商品","item_price":123456
```

**搜索**

q窗口：搜索条件

```
*:*  //匹配所有
```

```
"item_title":"测试商品" // 匹配item_title字段为测试商品的
```

df窗口：默认搜索域

```
item_keywords // 默认匹配搜索该域下的所有
```

**修改索引**

在solr中没有update，只需要添加一个新的文档，要求文档id和被修改文档的id一致。原理是先删除后添加。

**删除索引**

使用xml格式。

删除两种方法：

1、根据id删除：

```xml
<delete>

<id>test001</id>

</delete>

<commit/>
```

2、根据查询删除：

```xml
<delete>

<query>*:*</query>

</delete>

<commit/>
```

## solrJ客户端

要实现solr对商品的搜索功能，必须将商品的数据导入到solr里面，这里就需要使用到solrJ客户端。

需要依赖solrj的jar包。

```xml
<!-- solr客户端 -->
		<dependency>
			<groupId>org.apache.solr</groupId>
			<artifactId>solr-solrj</artifactId>
		</dependency>
```

### solrj的使用

```java
public class SolrJTest {

	@Test
	public void addDocument() throws Exception {
		//创建一连接
		SolrServer solrServer = new HttpSolrServer("http://192.168.25.154:8080/solr");
		//创建一个文档对象
		SolrInputDocument document = new SolrInputDocument();
		document.addField("id", "test001");
		document.addField("item_title", "测试商品2");
		document.addField("item_price", 54321);
		//把文档对象写入索引库
		solrServer.add(document);
		//提交
		solrServer.commit();
	}
	
	@Test
	public void deleteDocument() throws Exception {
		//创建一连接
		SolrServer solrServer = new HttpSolrServer("http://192.168.25.154:8080/solr");
		//solrServer.deleteById("test001");
		solrServer.deleteByQuery("*:*");
		solrServer.commit();
	}
}

```

### 把商品信息导入到索引库

使用java程序读取mysql数据库中的商品信息，然后创建solr文档对象，把商品信息写入索引库。

需要发布一个服务。

 为了灵活的进行分布式部署需要创建一搜素的服务工程发布 搜素服务。Taotao-search。

**系统架构**

![taotao-search系统架构](https://i.ibb.co/N1mM4T1/taotao-search.png)

**创建taotao-search工程**

**Pom文件**

需要依赖taotao-common工程

需要依赖的jar包：Spring的jar包、Springmvc的jar包、Solrj的jar包、Mybatis的jar包、参考taotao-rest工程。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>com.taotao</groupId>
		<artifactId>taotao-parent</artifactId>
		<version>0.0.1-SNAPSHOT</version>
	</parent>
	<groupId>com.taotao</groupId>
	<artifactId>taotao-search</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<dependencies>
		<dependency>
			<groupId>com.taotao</groupId>
			<artifactId>taotao-manager-mapper</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-beans</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aspects</artifactId>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- solr客户端 -->
		<dependency>
			<groupId>org.apache.solr</groupId>
			<artifactId>solr-solrj</artifactId>
		</dependency>
	</dependencies>
	<build>
		<!-- 配置插件 -->
		<plugins>
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<configuration>
					<port>8083</port>
					<path>/</path>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>

```

**Web.xml**

参考taotao-rest进行配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="taotao" version="2.5">
	<display-name>taotao-search</display-name>
	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
	<!-- 加载spring容器 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:spring/applicationContext-*.xml</param-value>
	</context-param>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	<!-- 解决post乱码 -->
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<!-- springmvc的前端控制器 -->
	<servlet>
		<servlet-name>taotao-search</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" -->
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>taotao-search</servlet-name>
		<url-pattern>/search/*</url-pattern>
	</servlet-mapping>
</web-app>
```

**框架整合**

参考taotao-rest工程

### 导入商品数据

**需要使用的表**

tb_item,tb_item_cat,tb_item_desc

**Sql语句**

```sql
SELECT
	a.id,
	a.title,
	a.sell_point,
	a.price,
	a.image,
--name是别名
	b.`name` category_name,
	c.item_desc
FROM
	tb_item a
LEFT JOIN tb_item_cat b ON a.cid = b.id
LEFT JOIN tb_item_desc c ON a.id = c.item_id
```

**Dao层**

需要创建一个mapper接口+mapper映射文件。名称相同且在同一目录下。

1、pojo

创建一个sql语句对应的pojo；

setter和getter自动生成；

```java
public class Item {

	private String id;
	private String title;
	private String sell_point;
	private long price;
	private String image;
	private String category_name;
	private String item_des;
}
```

2、接口定义

```java
public interface ItemMapper {
	List<Item> getItemList();
}
```

3、Mapper文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.taotao.search.mapper.ItemMapper" >
	
	<select id="getItemList" resultType="com.taotao.search.pojo.Item">
		SELECT
			a.id,
			a.title,
			a.sell_point,
			a.price,
			a.image,
			b. NAME category_name
		FROM
			tb_item a
		LEFT JOIN tb_item_cat b ON a.cid = b.id
	</select>

</mapper>

```

**Service层**

功能：导入所有的商品数据。没有参数。返回结果TaotaoResult。从数据库中查询出所有的商品数据。创建一个SolrInputDocument对象，把对象写入索引库。

```java
@Service
public class ItemServiceImpl implements ItemService {

	@Autowired
	private ItemMapper itemMapper;
	
	@Autowired
	private SolrServer solrServer;
	
	@Override
	public TaotaoResult importAllItems() {
		try {
			
			//查询商品列表
			List<Item> list = itemMapper.getItemList();
			//把商品信息写入索引库
			for (Item item : list) {
				//创建一个SolrInputDocument对象
				SolrInputDocument document = new SolrInputDocument();
				document.setField("id", item.getId());
				document.setField("item_title", item.getTitle());
				document.setField("item_sell_point", item.getSell_point());
				document.setField("item_price", item.getPrice());
				document.setField("item_image", item.getImage());
				document.setField("item_category_name", item.getCategory_name());
				document.setField("item_desc", item.getItem_des());
				//写入索引库
				solrServer.add(document);
			}
			//提交修改
			solrServer.commit();
		} catch (Exception e) {
			e.printStackTrace();
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
		return TaotaoResult.ok();
	}

}
```

applicationContext-solr.xml

```xml
<!-- 配置SolrServer对象 -->
	<!-- 单机版 -->
	<bean id="httpSolrServer" class="org.apache.solr.client.solrj.impl.HttpSolrServer">
		<constructor-arg name="baseURL" value="${SOLR.SERVER.URL}"></constructor-arg>
	</bean>
```

```
SOLR.SERVER.URL=http://192.168.222.128:8080/solr
```

访问的url必须包含http；

**Controller层**

功能：发布一个rest形式的服务。调用Service的服务方法，把数据导入到索引库中，返回TaotaoResult。

Url：/search/manager/importall

```java
@Controller
@RequestMapping("/manager")
public class ItemController {
	
	@Autowired
	private ItemService itemService;

	/**
	 * 导入商品数据到索引库
	 */
	@RequestMapping("/importall")
	@ResponseBody
	public TaotaoResult importAllItems() {
		TaotaoResult result = itemService.importAllItems();
		return result;
	}
}
```

修改pom文件，添加如下配置：

```xml
<build>	
	<resources>
			<resource>
				<directory>src/main/java</directory>
				<includes>
					<include>**/*.properties</include>
					<include>**/*.xml</include>
				</includes>
				<filtering>false</filtering>
			</resource>
			<resource>
				<directory>src/main/resources</directory>
				<includes>
					<include>**/*.properties</include>
					<include>**/*.xml</include>
				</includes>
				<filtering>false</filtering>
			</resource>
		</resources>
	</build>
```

在自己写mapper的时候都需要这样配置，这样才会将xml文件和properties文件发布到target中的classes文件下。

启动tomcat，在浏览器中输入<http://localhost:8083/search/manager/importall>，就可以将商品数据导入到索引库。

## 搜索服务发布

### 需求分析

http形式的服务。对外提供搜索服务是一个get形式的服务。调用此服务时需要查询条件，分页条件可以使用page（要显示第几页）、rows（每页显示的记录数）。返回一个json格式的数据。可以使用TaotaoResult包装一个商品列表转换成json。

请求的url：~~/search/query/{查询条件}/{page}/{rows}~~

​           /search/query?q={查询条件}&page={page}&rows={rows}

返回的结果：TaotaoResult包装商品列表。

### Dao层

分析：尽可能的做的通用一些。参数应该是SolrQuery。返回商品列表、查询结果总记录数

查询测试：

```java
@Test
	public void queryDocument() throws Exception {
		SolrServer solrServer = new HttpSolrServer("http://192.168.222.128:8080/solr");
		//创建一个查询对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery("*:*");
		query.setStart(20);
		query.setRows(50);
		//执行查询
		QueryResponse response = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = response.getResults();
		System.out.println("共查询到记录：" + solrDocumentList.getNumFound());
		for (SolrDocument solrDocument : solrDocumentList) {
			System.out.println(solrDocument.get("id"));
			System.out.println(solrDocument.get("item_title"));
			System.out.println(solrDocument.get("item_price"));
			System.out.println(solrDocument.get("item_image"));
			
		}
	}

```

返回结果pojo：

```java
public class SearchResult {

	//商品列表
	private List<Item> itemList;
	//总记录数
	private long recordCount;
	//总页数
	private long pageCount;
	//当前页
	private long curPage;
}

```

```java
@Repository
public class SearchDaoImpl implements SearchDao {
	
	@Autowired
	private SolrServer solrServer;

	@Override
	public SearchResult search(SolrQuery query) throws Exception {
		//返回值对象
		SearchResult result = new SearchResult();
		//根据查询条件查询索引库
		QueryResponse queryResponse = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//取查询结果总数量
		result.setRecordCount(solrDocumentList.getNumFound());
		//商品列表
		List<Item> itemList = new ArrayList<>();
		//取高亮显示
		Map<String, Map<String, List<String>>> highlighting = queryResponse.getHighlighting();
		//取商品列表
		for (SolrDocument solrDocument : solrDocumentList) {
			//创建一商品对象
			Item item = new Item();
			item.setId((String) solrDocument.get("id"));
			//取高亮显示的结果
			List<String> list = highlighting.get(solrDocument.get("id")).get("item_title");
			String title = "";
			if (list != null && list.size()>0) {
				title = list.get(0);
			} else {
				title = (String) solrDocument.get("item_title");
			}
			item.setTitle(title);
			item.setImage((String) solrDocument.get("item_image"));
			item.setPrice((long) solrDocument.get("item_price"));
			item.setSell_point((String) solrDocument.get("item_sell_point"));
			item.setCategory_name((String) solrDocument.get("item_category_name"));
			//添加的商品列表
			itemList.add(item);
		}
		result.setItemList(itemList);
		return result;
	}

}

```

### Service层

功能：接收查询条件。查询条件及分页条件（page、rows），创建一个SolrQuery对象。指定查询条件、分页条件、默认搜索域、高亮显示。调用dao层执行查询。得到查询结果计算总页数。返回SearchResult对象。

```java
@Service
public class SearchServiceImpl implements SearchService {

	@Autowired
	private SearchDao searchDao;
	@Override
	public SearchResult search(String queryString, int page, int rows) throws Exception {
		//创建查询对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery(queryString);
		//设置分页
		query.setStart((page - 1) * rows);
		query.setRows(rows);
		//设置默认搜素域
		query.set("df", "item_keywords");
		//设置高亮显示
		query.setHighlight(true);
		query.addHighlightField("item_title");
		query.setHighlightSimplePre("<em style=\"color:red\">");
		query.setHighlightSimplePost("</em>");
		//执行查询
		SearchResult searchResult = searchDao.search(query);
		//计算查询结果总页数
		long recordCount = searchResult.getRecordCount();
		long pageCount = recordCount / rows;
		if (recordCount % rows > 0) {
			pageCount++;
		}
		searchResult.setPageCount(pageCount);
		searchResult.setCurPage(page);
		
		return searchResult;
	}

}

```

### Controller层

接收查询参数：查询条件、page、rows

调用Service执行查询返回一个查询结果对象。

把查询结果包装到TaotaoResult中返回，结果是json格式的数据。

如果查询条件为空，返回状态码：400，消息：查询条件不能为空。

Page为空：默认为1

Rows 为空：默认为60

```java
@Controller
public class SearchController {

	@Autowired
	private SearchService searchService;
	
	@RequestMapping(value="/query", method=RequestMethod.GET)
	@ResponseBody
	public TaotaoResult search(@RequestParam("q")String queryString, 
			@RequestParam(defaultValue="1")Integer page, 
			@RequestParam(defaultValue="60")Integer rows) {
		//查询条件不能为空
		if (StringUtils.isBlank(queryString)) {
			return TaotaoResult.build(400, "查询条件不能为空");
		}
		SearchResult searchResult = null;
		try {
			searchResult = searchService.search(queryString, page, rows);
		} catch (Exception e) {
			e.printStackTrace();
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
		return TaotaoResult.ok(searchResult);
		
	}
	
}

```

扫描dao配置：

将Controller排除在外，因为springmvc容器中的bean不能被spring访问

```xml
<context:component-scan base-package="com.taotao.search">
	<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```
解决get乱码问题：

```java
public class SearchController {

	@Autowired
	private SearchService searchService;
	
	@RequestMapping(value="/query", method=RequestMethod.GET)
	@ResponseBody
	public TaotaoResult search(@RequestParam("q")String queryString, 
			@RequestParam(defaultValue="1")Integer page, 
			@RequestParam(defaultValue="60")Integer rows) {
		//查询条件不能为空
		if (StringUtils.isBlank(queryString)) {
			return TaotaoResult.build(400, "查询条件不能为空");
		}
		SearchResult searchResult = null;
		try {
            // 解决乱码问题
			queryString=new String(queryString.getBytes("iso8859-1"),"utf-8");
			searchResult = searchService.search(queryString, page, rows);
		} catch (Exception e) {
			e.printStackTrace();
			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));
		}
		return TaotaoResult.ok(searchResult);
		
	}
	
}
```

启动tomcat，在浏览器中输入<http://localhost:8083/search/query?q=手机>，就可以查询到所有的手机商品，并显示第一页，如果要显示第二页，访问<http://localhost:8083/search/query?q=手机&page=2>

# 商品详情页面实现

## 商品搜索的实现

### 需求分析

用户在首页中输入查询条件，点击查询向taotao-portal发送请求，参数就是查询的条件，页码。Taoto-portal调用taotao-search发布的服务进行搜索，参数应该是查询条件和页码及每页显示的记录数（参数可选）。Taotao-search返回一个json格式的数据（TaotaoResult包装一个SearchResult对象）。Taotao-portal接收json数据需要把json数据转换成java对象。把java对象传递给jsp页面，jsp渲染java对象得到商品查询结果页面。

### JSP

搜索框在前台的所有页面都应该存在，所以应该在commons文件夹下去找header

```javascript
<script type="text/javascript" src="/js/base-v1.js" charset="utf-8"></script>
```

得知搜索框使用了js文件/js/base-v1.js，在该文件中找到search功能

```javascript
function search(a) {
    var b = "http://localhost:8082/search.html?q=" + encodeURIComponent(document.getElementById(a).value);
    return window.location.href = b;
}
```

得知请求url：<http://localhost:8082/search.html?q=查询条件>

搜索的结果在search.jsp中：

```
Query：回显的查询条件

totalPages：总页数

itemList：商品列表

Page：当前页码
```

### Service层

接收两个参数1、查询条件2、页码。调用taotao-search的搜索服务。接收返回的json数据，把json转换成java对象返回SearchResult对象。

从taotao-search中复制SearchResult和Item两个pojo类。

```java
@Service
public class SearchServiceImpl implements SearchService {

	@Value("${SEARCH_BASE_URL}")
	private String SEARCH_BASE_URL;
	
	@Override
	public SearchResult search(String queryString, int page) {
		// 调用taotao-search的服务
		//查询参数
		Map<String, String> param = new HashMap<>();
		param.put("q", queryString);
		param.put("page", page + "");
		try {
			//调用服务
			String json = HttpClientUtil.doGet(SEARCH_BASE_URL, param);
			//把字符串转换成java对象
			TaotaoResult taotaoResult = TaotaoResult.formatToPojo(json, SearchResult.class);
			if (taotaoResult.getStatus() == 200) {
				SearchResult result = (SearchResult) taotaoResult.getData();
				return result;
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
```

### Controller层

功能：接收请求的参数查询条件和页码。调用Service查询商品列表得到SearchResult对象。

需要把

query：回显的查询条件

totalPages：总页数

itemList：商品列表

Page：当前页码

传递到页面。返回一个逻辑视图search字符串。

```java
@Controller
public class SearchController {

	@Autowired
	private SearchService searchService;
	
	@RequestMapping("/search")
	public String search(@RequestParam("q")String queryString, @RequestParam(defaultValue="1")Integer page, Model model) {
		if (queryString != null) {
			try {
				queryString = new String(queryString.getBytes("iso8859-1"), "utf-8");
			} catch (UnsupportedEn··codingException e) {
				e.printStackTrace();
			}
		}
		SearchResult searchResult = searchService.search(queryString, page);
		//向页面传递参数
		model.addAttribute("query", queryString);
		model.addAttribute("totalPages", searchResult.getPageCount());
		model.addAttribute("itemList", searchResult.getItemList());
		model.addAttribute("page", page);
		
		return "search";
		
	}
}
```

### 存在的问题

搜索结果中图片展示不出来，image字段中存储的图片是多张，使用逗号分隔。

修改方法：

pojo中（将多张图片以数组的形式保存）

```java
	public String[] getImages() {
		if(image!=null) {
			String[] images=image.split(",");
			return images;
		}
		return null;
	}
```

search.jsp中（取多张图片中的第一张展示出来即可）

```xml
<img width="160" height="160" data-img="1" data-lazyload="${item.images[0]}" />
```

## 商品详情页面展示

### 需求分析

需要在taotao-portal中调用taotao-rest发布的服务，查询商品详情。

1、商品的基本信息

2、商品的描述

3、商品的规格

当用户请求商品详情页面时，只需要把商品基本信息展示出来，为了快速响应用户。商品的描述可以延迟加载，延迟一秒钟加载。商品的规格参数按需加载，当用户点击商品规格参数的标签页此时加载。

### 服务发布

需要在taotao-rest工程中发布服务

1、取商品基本信息的服务

2、取商品描述的服务

3、取商品规格的服务

需要把商品信息添加到缓存中。设置商品的过期时间，过期时间为一天。需要缓存同步。

**取商品基本信息**

1、Dao层

查询的表tb_item

2、Service层

接收商品id，根据商品id查询商品基本信息。返回一个商品的pojo，使用taotaoResult包装返回。

```java
@Service
public class ItemServiceImpl implements ItemService {

	@Autowired
	private TbItemMapper itemMapper;
	@Override
	public TaotaoResult getItemBaseInfo(long itemId) {
		//根据商品id查询商品信息
		TbItem item = itemMapper.selectByPrimaryKey(itemId);
		//使用TaotaoResult包装一下
		
		return TaotaoResult.ok(item);
	}

}
```

3、Controller层

接收商品id调用Service查询商品信息，返回商品对象，使用TaotaoResult包装。

Url：/rest/item/info/{itemId}

```java
@Controller
@RequestMapping("/item")
public class ItemController {

	@Autowired
	private ItemService itemService;
	
	@RequestMapping("/info/{itemId}")
	@ResponseBody
	public TaotaoResult getItemBaseInfo(@PathVariable Long itemId) {
		TaotaoResult result = itemService.getItemBaseInfo(itemId);
		return result;
	}
	
}
```

4、添加缓存逻辑

Redis的hash类型中的key是不能设置过期时间。如果还需要对key进行分类可以使用折中的方案。

Key的命名方式：

Itheima:javaee16:01=袁飞

Itheima:javaee16:02=张飞

商品key的定义：

基本信息：

REDIS_ITEM_KEY:商品id:base=json

描述：

REDIS_ITEM_KEY:商品id:desc=json

规格参数：

REDIS_ITEM_KEY:商品id:param=json

需要确定一下REDIS_ITEM_EXPIRE的值。

```java
	@Override
	public TaotaoResult getItemBaseInfo(long itemId) {
		try {
			//添加缓存逻辑
			//从缓存中取商品信息，商品id对应的信息
			String json = redisService.get(REDIS_ITEM_KEY + ":" + itemId + ":base");
			//判断是否有值
			if (!StringUtils.isBlank(json)) {
				//把json转换成java对象
				TbItem item = JsonUtils.jsonToPojo(json, TbItem.class);
				return TaotaoResult.ok(item);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//根据商品id查询商品信息
		TbItem item = itemMapper.selectByPrimaryKey(itemId);
		//使用TaotaoResult包装一下
		try {
			//把商品信息写入缓存
			redisService.set(REDIS_ITEM_KEY + ":" + itemId + ":base", JsonUtils.objectToJson(item));
			//设置key的有效期
			redisService.expire(REDIS_ITEM_KEY + ":" + itemId + ":base", REDIS_ITEM_EXPIRE);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return TaotaoResult.ok(item);
	}
```



**取商品描述信息**

根据商品id取商品描述信息。单表查询tb_item_desc。

1、Service层

接收商品id根据商品id查询商品描述。返回商品描述的pojo。使用TaotaoResult包装。

需要添加缓存逻辑。

```java
	@Override
	public TaotaoResult getItemDesc(long itemId) {
		//添加缓存
		try {
			//添加缓存逻辑
			//从缓存中取商品信息，商品id对应的信息
			String json = redisService.get(REDIS_ITEM_KEY + ":" + itemId + ":desc");
			//判断是否有值
			if (!StringUtils.isBlank(json)) {
				//把json转换成java对象
				TbItemDesc itemDesc = JsonUtils.jsonToPojo(json, TbItemDesc.class);
				return TaotaoResult.ok(itemDesc);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		//创建查询条件
		TbItemDesc itemDesc = itemDescMapper.selectByPrimaryKey(itemId);
		
		try {
			//把商品信息写入缓存
			redisService.set(REDIS_ITEM_KEY + ":" + itemId + ":desc", JsonUtils.objectToJson(itemDesc));
			//设置key的有效期
			redisService.expire(REDIS_ITEM_KEY + ":" + itemId + ":desc", REDIS_ITEM_EXPIRE);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return TaotaoResult.ok(itemDesc);
	}
```

**取商品规格参数**

需要从tb_item_param_item表中根据商品id取出商品的规格参数信息。返回pojo对象，使用TaotaoResult包装。

1、Service层

接收商品id调用mapper查询商品规格参数，返回规格参数pojo使用TaotaoResult包装。添加缓存逻辑。

```java
	@Override
	public TaotaoResult getItemParam(long itemId) {
		//添加缓存
		try {
			//添加缓存逻辑
			//从缓存中取商品信息，商品id对应的信息
			String json = redisService.get(REDIS_ITEM_KEY + ":" + itemId + ":param");
			//判断是否有值
			if (!StringUtils.isBlank(json)) {
				//把json转换成java对象
				TbItemParamItem paramItem = JsonUtils.jsonToPojo(json, TbItemParamItem.class);
				return TaotaoResult.ok(paramItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		//根据商品id查询规格参数
		//设置查询条件
		TbItemParamItemExample example = new TbItemParamItemExample();
		Criteria criteria = example.createCriteria();
		criteria.andItemIdEqualTo(itemId);
		//执行查询
		List<TbItemParamItem> list = itemParamItemMapper.selectByExampleWithBLOBs(example);
		if (list != null && list.size()>0) {
			TbItemParamItem paramItem = list.get(0);
			try {
				//把商品信息写入缓存
				redisService.set(REDIS_ITEM_KEY + ":" + itemId + ":param", JsonUtils.objectToJson(paramItem));
				//设置key的有效期
				redisService.expire(REDIS_ITEM_KEY + ":" + itemId + ":param", REDIS_ITEM_EXPIRE);
			} catch (Exception e) {
				e.printStackTrace();
			}
			return TaotaoResult.ok(paramItem);
		}
		return TaotaoResult.build(400, "无此商品规格");
	}
```

### 调用服务

**需求分析**

当用户访问商品详情页面时，需要加载商品基本信息。延迟加载商品描述、按需加载商品的规格参数。

**商品基本信息的查询**

当商品页面展示时，数据已经到位。

请求的url：/item/{itemId}.html

1、Service层

接收商品id，调用taotao-rest的服务，查询商品的基本信息。得到一个json字符串。需要把json转换成java对象。然后在jsp页面渲染。

```java
@Service
public class ItemServiceImpl implements ItemService {
	
	
	@Value("${REST_BASE_URL}")
	private String REST_BASE_URL;
	@Value("${ITME_INFO_URL}")
	private String ITME_INFO_URL;

	@Override
	public ItemInfo getItemById(Long itemId) {

		try {
			//调用rest的服务查询商品基本信息
			String json = HttpClientUtil.doGet(REST_BASE_URL + ITME_INFO_URL + itemId);
			if (!StringUtils.isBlank(json)) {
				TaotaoResult taotaoResult = TaotaoResult.formatToPojo(json, ItemInfo.class);
				if (taotaoResult.getStatus() == 200) {
					ItemInfo item = (ItemInfo) taotaoResult.getData();
					return item;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}

}
```

2、Controller层

接收页面传递过来的商品id，调用Service查询商品基本信息。传递给jsp页面。返回逻辑视图，展示商品详情页面。

```java
@Controller
public class ItemController {
	
	@Autowired
	private ItemService itemService;

	@RequestMapping("/item/{itemId}")
	public String showItem(@PathVariable Long itemId, Model model) {
		ItemInfo item = itemService.getItemById(itemId);
		model.addAttribute("item", item);
		
		return "item";
	}
}
```

由于TbItem没有getImages方法，所以需要创建一个pojo继承TbItem并加入该方法

```java
public class ItemInfo extends TbItem {

	public String[] getImages() {
		String image = getImage();
		if (image != null) {
			String[] images = image.split(",");
			return images;
		}
		return null;
	}
}

```

**商品描述延迟加载**

当商品详情页面加载完毕后延迟一秒钟ajax请求商品详情。

请求的URL：/item/desc/{itemId}.html

参数：商品id

返回值：商品描述信息（html片段）

1、Service层

接收商品id，调用taotao-rest的服务根据商品id查询商品描述信息。得到json数据。把json转换成java对象从java对象中把商品描述取出来。返回商品描述字符串。

参数：商品id

返回值：字符串（商品描述的html片段）

```java
	@Override
	public String getItemDescById(Long itemId) {
		try {
			//查询商品描述
			String json = HttpClientUtil.doGet(REST_BASE_URL + ITEM_DESC_URL + itemId);
			//转换成java对象
			TaotaoResult taotaoResult = TaotaoResult.formatToPojo(json, TbItemDesc.class);
			if (taotaoResult.getStatus() == 200) {
				TbItemDesc itemDesc = (TbItemDesc) taotaoResult.getData();
				//取商品描述信息
				String result = itemDesc.getItemDesc();
				return result;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
```

2、Controller层

接收商品id，调用Service查询商品的描述信息，返回一个字符串，是商品描述的片段。需要使用@ResponseBody。

```java
	@RequestMapping(value="/item/desc/{itemId}", produces=MediaType.TEXT_HTML_VALUE+";charset=utf-8")
	@ResponseBody
	public String getItemDesc(@PathVariable Long itemId) {
		String string = itemService.getItemDescById(itemId);
		return string;
	}
```

**商品规格参数展示**

按需加载。当用户点击规格参数tab页时触发一个单击事件，在事件中异步加载规格参数信息。规格参数内容是html片段。返回字符串。

1、Service层

接收商品id，根据商品id查询规格参数的数据，调用服务端的方法，返回json数据。把json转换成java对象，根据java对象生成html片段，返回。

参数：商品id

返回值：字符串（规格参数html）

```java
	@Override
	public String getItemParam(Long itemId) {
		try {
			String json = HttpClientUtil.doGet(REST_BASE_URL + ITEM_PARAM_URL + itemId);
			//把json转换成java对象
			TaotaoResult taotaoResult = TaotaoResult.formatToP(json, TbItemParamItem.class);
			if (taotaoResult.getStatus() == 200) {
				TbItemParamItem itemParamItem = (TbItemParamItem) taotaoResult.getData();
				String paramData = itemParamItem.getParamData();
				//生成html
				// 把规格参数json数据转换成java对象
				List<Map> jsonList = JsonUtils.jsonToList(paramData, Map.class);
				StringBuffer sb = new StringBuffer();
				sb.append("<table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\">\n");
				sb.append("    <tbody>\n");
				for(Map m1:jsonList) {
					sb.append("        <tr>\n");
					sb.append("            <th class=\"tdTitle\" colspan=\"2\">"+m1.get("group")+"</th>\n");
					sb.append("        </tr>\n");
					List<Map> list2 = (List<Map>) m1.get("params");
					for(Map m2:list2) {
						sb.append("        <tr>\n");
						sb.append("            <td class=\"tdTitle\">"+m2.get("k")+"</td>\n");
						sb.append("            <td>"+m2.get("v")+"</td>\n");
						sb.append("        </tr>\n");
					}
				}
				sb.append("    </tbody>\n");
				sb.append("</table>");
				//返回html片段
				return sb.toString();
			}
				 
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return "";
	}

```

2、Controller层

页面的ajax请求Controller，请求的url://item/param/{itemId}.html

响应一个字符串。规格参数的片段。@ResponseBody。

```java
@RequestMapping(value="/item/param/{itemId}", produces=MediaType.TEXT_HTML_VALUE+";charset=utf-8")
	@ResponseBody
	public String getItemParam(@PathVariable Long itemId) {
		String string = itemService.getItemParam(itemId);
		return string;
	}

```

3、Jsp

响应规格参数标签页的点击事件，在事件中进行ajax请求规格参数。只需要请求一次即可。

给tab页dom节点绑定单击事件：

# 单点登录系统

搭建系统的步骤：

1、创建单点登录工程，独立的工程

2、发布登录、注册的接口

3、实现登录、注册的功能

## 单点登录系统的概念

### 什么是SSO

SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。

### 传统的登录流程

用户填写登录信息后，将信息与数据库中的信息匹配，如果能够匹配，将用户信息写入到session中，然后进行页面跳转。

传统流程中的问题：集群环境中，需要把同一套代码部署到多台服务器上，每个工程都有自己独立的session，不能实现单点登录

### 解决方案

方案1、可以配置tomcat的session共享。配置tomcat集群。Tomcat配置好集群后，会不停的向集群中其他的tomcat广播自己的session信息。其他的tomcat做session同步。可以保证所有的tomcatsession中的内容都是一致的。

优点：不用修改代码就可以实现session共享。

缺点：tomcat 是全局session复制，集群内每个tomcat的session完全同步（也就是任何时候都完全一样的) 在大规模应用的时候，用户过多，集群内tomcat数量过多，session的全局复制会导致集群性能下降， 因此，tomcat的数量不能太多，5个以下为好。不能解决分布式工程的session共享问题。例如支付宝和淘宝单点登录的问题。

方案2、实现单点登录系统，提供服务接口。把session数据存放在redis。

Redis可以设置key的生存时间、访问速度快效率高。

优点：redis存取速度快，不会出现多个节点session复制的问题。效率高。

